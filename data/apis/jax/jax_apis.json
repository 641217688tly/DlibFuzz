{
  "1": {
    "name": "block_until_ready",
    "module": "jax",
    "fullName": "jax.block_until_ready",
    "signature": "(x)",
    "description": "Tries to call a ``block_until_ready`` method on pytree leaves."
  },
  "2": {
    "name": "checkpoint",
    "module": "jax",
    "fullName": "jax.checkpoint",
    "signature": "(fun: Callable, *, prevent_cse: bool = True, policy: Optional[Callable[..., bool]] = None, static_argnums: Union[int, Tuple[int, ...]] = ()) -> Callable",
    "description": "Make ``fun`` recompute internal linearization points when differentiated."
  },
  "3": {
    "name": "clear_backends",
    "module": "jax",
    "fullName": "jax.clear_backends",
    "signature": "()",
    "description": "Clear all backend clients so that new backend clients can be created later."
  },
  "4": {
    "name": "clear_caches",
    "module": "jax",
    "fullName": "jax.clear_caches",
    "signature": "()",
    "description": "Clear all compilation and staging caches."
  },
  "5": {
    "name": "closure_convert",
    "module": "jax",
    "fullName": "jax.closure_convert",
    "signature": "(fun: Callable, *example_args) -> Tuple[Callable, List[Any]]",
    "description": "Closure conversion utility, for use with higher-order custom derivatives."
  },
  "6": {
    "name": "custom_gradient",
    "module": "jax",
    "fullName": "jax.custom_gradient",
    "signature": "(fun)",
    "description": "Convenience function for defining custom VJP rules (aka custom gradients)."
  },
  "7": {
    "name": "default_backend",
    "module": "jax",
    "fullName": "jax.default_backend",
    "signature": "() -> str",
    "description": "Returns the platform name of the default XLA backend."
  },
  "8": {
    "name": "device_count",
    "module": "jax",
    "fullName": "jax.device_count",
    "signature": "(backend: Union[str, jaxlib.xla_extension.Client, NoneType] = None) -> int",
    "description": "Returns the total number of devices."
  },
  "9": {
    "name": "device_get",
    "module": "jax",
    "fullName": "jax.device_get",
    "signature": "(x: 'Any')",
    "description": "Transfer ``x`` to host."
  },
  "10": {
    "name": "device_put",
    "module": "jax",
    "fullName": "jax.device_put",
    "signature": "(x, device: 'Union[None, xc.Device, Sharding, Any]' = None, *, src: 'Union[None, xc.Device, Sharding, Any]' = None)",
    "description": "Transfers ``x`` to ``device``."
  },
  "11": {
    "name": "device_put_replicated",
    "module": "jax",
    "fullName": "jax.device_put_replicated",
    "signature": "(x: 'Any', devices: 'Sequence[xc.Device]')",
    "description": "Transfer array(s) to each specified device and form Array(s)."
  },
  "12": {
    "name": "device_put_sharded",
    "module": "jax",
    "fullName": "jax.device_put_sharded",
    "signature": "(shards: 'Sequence[Any]', devices: 'Sequence[xc.Device]')",
    "description": "Transfer array shards to specified devices and form Array(s)."
  },
  "13": {
    "name": "devices",
    "module": "jax",
    "fullName": "jax.devices",
    "signature": "(backend: Union[str, jaxlib.xla_extension.Client, NoneType] = None) -> List[jaxlib.xla_extension.Device]",
    "description": "Returns a list of all devices for a given backend."
  },
  "14": {
    "name": "disable_jit",
    "module": "jax",
    "fullName": "jax.disable_jit",
    "signature": "(disable: 'bool' = True)",
    "description": "Context manager that disables :py:func:`jit` behavior under its dynamic context."
  },
  "15": {
    "name": "effects_barrier",
    "module": "jax",
    "fullName": "jax.effects_barrier",
    "signature": "()",
    "description": "Waits until existing functions have completed any side-effects."
  },
  "16": {
    "name": "ensure_compile_time_eval",
    "module": "jax",
    "fullName": "jax.ensure_compile_time_eval",
    "signature": "()",
    "description": "Context manager to ensure evaluation at trace/compile time (or error)."
  },
  "17": {
    "name": "eval_shape",
    "module": "jax",
    "fullName": "jax.eval_shape",
    "signature": "(fun: 'Callable', *args, **kwargs)",
    "description": "Compute the shape/dtype of ``fun`` without any FLOPs."
  },
  "18": {
    "name": "grad",
    "module": "jax",
    "fullName": "jax.grad",
    "signature": "(fun: 'Callable', argnums: 'Union[int, Sequence[int]]' = 0, has_aux: 'bool' = False, holomorphic: 'bool' = False, allow_int: 'bool' = False, reduce_axes: 'Sequence[AxisName]' = ()) -> 'Callable'",
    "description": "Creates a function that evaluates the gradient of ``fun``."
  },
  "19": {
    "name": "hessian",
    "module": "jax",
    "fullName": "jax.hessian",
    "signature": "(fun: 'Callable', argnums: 'Union[int, Sequence[int]]' = 0, has_aux: 'bool' = False, holomorphic: 'bool' = False) -> 'Callable'",
    "description": "Hessian of ``fun`` as a dense array."
  },
  "20": {
    "name": "host_count",
    "module": "jax",
    "fullName": "jax.host_count",
    "signature": "(backend: Union[str, jaxlib.xla_extension.Client, NoneType] = None) -> int",
    "description": "No description available."
  },
  "21": {
    "name": "host_id",
    "module": "jax",
    "fullName": "jax.host_id",
    "signature": "(backend: Union[str, jaxlib.xla_extension.Client, NoneType] = None) -> int",
    "description": "No description available."
  },
  "22": {
    "name": "host_ids",
    "module": "jax",
    "fullName": "jax.host_ids",
    "signature": "(backend: Union[str, jaxlib.xla_extension.Client, NoneType] = None) -> List[int]",
    "description": "No description available."
  },
  "23": {
    "name": "jacfwd",
    "module": "jax",
    "fullName": "jax.jacfwd",
    "signature": "(fun: 'Callable', argnums: 'Union[int, Sequence[int]]' = 0, has_aux: 'bool' = False, holomorphic: 'bool' = False) -> 'Callable'",
    "description": "Jacobian of ``fun`` evaluated column-by-column using forward-mode AD."
  },
  "24": {
    "name": "jacobian",
    "module": "jax",
    "fullName": "jax.jacobian",
    "signature": "(fun: 'Callable', argnums: 'Union[int, Sequence[int]]' = 0, has_aux: 'bool' = False, holomorphic: 'bool' = False, allow_int: 'bool' = False) -> 'Callable'",
    "description": "Jacobian of ``fun`` evaluated row-by-row using reverse-mode AD."
  },
  "25": {
    "name": "jacrev",
    "module": "jax",
    "fullName": "jax.jacrev",
    "signature": "(fun: 'Callable', argnums: 'Union[int, Sequence[int]]' = 0, has_aux: 'bool' = False, holomorphic: 'bool' = False, allow_int: 'bool' = False) -> 'Callable'",
    "description": "Jacobian of ``fun`` evaluated row-by-row using reverse-mode AD."
  },
  "26": {
    "name": "jit",
    "module": "jax",
    "fullName": "jax.jit",
    "signature": "(fun: 'Callable', in_shardings=UnspecifiedValue, out_shardings=UnspecifiedValue, static_argnums: 'Union[int, Sequence[int], None]' = None, static_argnames: 'Union[str, Iterable[str], None]' = None, donate_argnums: 'Union[int, Sequence[int]]' = (), keep_unused: 'bool' = False, device: 'Optional[xc.Device]' = None, backend: 'Optional[str]' = None, inline: 'bool' = False, abstracted_axes: 'Optional[Any]' = None) -> 'stages.Wrapped'",
    "description": "Sets up ``fun`` for just-in-time compilation with XLA."
  },
  "27": {
    "name": "jvp",
    "module": "jax",
    "fullName": "jax.jvp",
    "signature": "(fun: 'Callable', primals, tangents, has_aux: 'bool' = False) -> 'Tuple[Any, ...]'",
    "description": "Computes a (forward-mode) Jacobian-vector product of ``fun``."
  },
  "28": {
    "name": "linear_transpose",
    "module": "jax",
    "fullName": "jax.linear_transpose",
    "signature": "(fun: 'Callable', *primals, reduce_axes=()) -> 'Callable'",
    "description": "Transpose a function that is promised to be linear."
  },
  "29": {
    "name": "linearize",
    "module": "jax",
    "fullName": "jax.linearize",
    "signature": "(fun: 'Callable', *primals, has_aux: 'bool' = False) -> 'Union[Tuple[Any, Callable], Tuple[Any, Callable, Any]]'",
    "description": "Produces a linear approximation to ``fun`` using :py:func:`jvp` and partial eval."
  },
  "30": {
    "name": "live_arrays",
    "module": "jax",
    "fullName": "jax.live_arrays",
    "signature": "(platform=None)",
    "description": "Return all live arrays in the backend for `platform`."
  },
  "31": {
    "name": "local_device_count",
    "module": "jax",
    "fullName": "jax.local_device_count",
    "signature": "(backend: Union[str, jaxlib.xla_extension.Client, NoneType] = None) -> int",
    "description": "Returns the number of devices addressable by this process."
  },
  "32": {
    "name": "local_devices",
    "module": "jax",
    "fullName": "jax.local_devices",
    "signature": "(process_index: Optional[int] = None, backend: Union[str, jaxlib.xla_extension.Client, NoneType] = None, host_id: Optional[int] = None) -> List[jaxlib.xla_extension.Device]",
    "description": "Like :py:func:`jax.devices`, but only returns devices local to a given process."
  },
  "33": {
    "name": "make_array_from_callback",
    "module": "jax",
    "fullName": "jax.make_array_from_callback",
    "signature": "(shape: 'Shape', sharding: 'Sharding', data_callback: 'Callable[[Optional[Index]], ArrayLike]') -> 'ArrayImpl'",
    "description": "Returns a ``jax.Array`` via data fetched from ``data_callback``."
  },
  "34": {
    "name": "make_array_from_single_device_arrays",
    "module": "jax",
    "fullName": "jax.make_array_from_single_device_arrays",
    "signature": "(shape: 'Shape', sharding: 'Sharding', arrays: 'Sequence[basearray.Array]') -> 'ArrayImpl'",
    "description": "Returns a ``jax.Array`` from a sequence of ``jax.Array``\\s on a single device."
  },
  "35": {
    "name": "make_jaxpr",
    "module": "jax",
    "fullName": "jax.make_jaxpr",
    "signature": "(fun: 'Callable', static_argnums: 'Union[int, Iterable[int]]' = (), axis_env: 'Optional[Sequence[Tuple[AxisName, int]]]' = None, return_shape: 'bool' = False, abstracted_axes: 'Optional[Any]' = None) -> 'Callable[..., Union[core.ClosedJaxpr, Tuple[core.ClosedJaxpr, Any]]]'",
    "description": "Creates a function that produces its jaxpr given example args."
  },
  "36": {
    "name": "named_call",
    "module": "jax",
    "fullName": "jax.named_call",
    "signature": "(fun: 'Callable[..., Any]', *, name: 'Optional[str]' = None) -> 'Callable[..., Any]'",
    "description": "Adds a user specified name to a function when staging out JAX computations."
  },
  "37": {
    "name": "named_scope",
    "module": "jax",
    "fullName": "jax.named_scope",
    "signature": "(name: 'str') -> 'Generator[None, None, None]'",
    "description": "A context manager that adds a user specified name to the JAX name stack."
  },
  "38": {
    "name": "pmap",
    "module": "jax",
    "fullName": "jax.pmap",
    "signature": "(fun: 'Callable', axis_name: 'Optional[AxisName]' = None, *, in_axes=0, out_axes=0, static_broadcasted_argnums: 'Union[int, Iterable[int]]' = (), devices: 'Optional[Sequence[xc.Device]]' = None, backend: 'Optional[str]' = None, axis_size: 'Optional[int]' = None, donate_argnums: 'Union[int, Iterable[int]]' = (), global_arg_shapes: 'Optional[Tuple[Tuple[int, ...], ...]]' = None) -> 'Any'",
    "description": "Parallel map with support for collective operations."
  },
  "39": {
    "name": "print_environment_info",
    "module": "jax",
    "fullName": "jax.print_environment_info",
    "signature": "(return_string: bool = False) -> Optional[str]",
    "description": "Returns a string containing local environment & JAX installation information."
  },
  "40": {
    "name": "process_count",
    "module": "jax",
    "fullName": "jax.process_count",
    "signature": "(backend: Union[str, jaxlib.xla_extension.Client, NoneType] = None) -> int",
    "description": "Returns the number of JAX processes associated with the backend."
  },
  "41": {
    "name": "process_index",
    "module": "jax",
    "fullName": "jax.process_index",
    "signature": "(backend: Union[str, jaxlib.xla_extension.Client, NoneType] = None) -> int",
    "description": "Returns the integer process index of this process."
  },
  "42": {
    "name": "pure_callback",
    "module": "jax",
    "fullName": "jax.pure_callback",
    "signature": "(callback: 'Callable[..., Any]', result_shape_dtypes: 'Any', *args: 'Any', vectorized: 'bool' = False, **kwargs: 'Any')",
    "description": "Applies a functionally pure Python callable. Works under :func:`jit`/:func:`~pmap`/etc."
  },
  "43": {
    "name": "remat",
    "module": "jax",
    "fullName": "jax.remat",
    "signature": "(fun: Callable, *, prevent_cse: bool = True, policy: Optional[Callable[..., bool]] = None, static_argnums: Union[int, Tuple[int, ...]] = ()) -> Callable",
    "description": "Make ``fun`` recompute internal linearization points when differentiated."
  },
  "44": {
    "name": "transfer_guard",
    "module": "jax",
    "fullName": "jax.transfer_guard",
    "signature": "(new_val: str) -> Iterator[NoneType]",
    "description": "A contextmanager to control the transfer guard level for all transfers."
  },
  "45": {
    "name": "tree_flatten",
    "module": "jax",
    "fullName": "jax.tree_flatten",
    "signature": "(tree: 'Any', is_leaf: 'Optional[Callable[[Any], bool]]' = None) -> 'Tuple[List[Leaf], PyTreeDef]'",
    "description": "Flattens a pytree."
  },
  "46": {
    "name": "tree_leaves",
    "module": "jax",
    "fullName": "jax.tree_leaves",
    "signature": "(tree: 'Any', is_leaf: 'Optional[Callable[[Any], bool]]' = None) -> 'List[Leaf]'",
    "description": "Gets the leaves of a pytree."
  },
  "47": {
    "name": "tree_map",
    "module": "jax",
    "fullName": "jax.tree_map",
    "signature": "(f: 'Callable[..., Any]', tree: 'Any', *rest: 'Any', is_leaf: 'Optional[Callable[[Any], bool]]' = None) -> 'Any'",
    "description": "Maps a multi-input function over pytree args to produce a new pytree."
  },
  "48": {
    "name": "tree_structure",
    "module": "jax",
    "fullName": "jax.tree_structure",
    "signature": "(tree: 'Any', is_leaf: 'Optional[Callable[[Any], bool]]' = None) -> 'PyTreeDef'",
    "description": "Gets the treedef for a pytree."
  },
  "49": {
    "name": "tree_transpose",
    "module": "jax",
    "fullName": "jax.tree_transpose",
    "signature": "(outer_treedef: 'PyTreeDef', inner_treedef: 'PyTreeDef', pytree_to_transpose: 'Any') -> 'Any'",
    "description": "Transform a tree having tree structure (outer, inner) into one having structure"
  },
  "50": {
    "name": "tree_unflatten",
    "module": "jax",
    "fullName": "jax.tree_unflatten",
    "signature": "(treedef: 'PyTreeDef', leaves: 'Iterable[Leaf]') -> 'Any'",
    "description": "Reconstructs a pytree from the treedef and the leaves."
  },
  "51": {
    "name": "treedef_is_leaf",
    "module": "jax",
    "fullName": "jax.treedef_is_leaf",
    "signature": "(treedef: 'PyTreeDef') -> 'bool'",
    "description": "No description available."
  },
  "52": {
    "name": "value_and_grad",
    "module": "jax",
    "fullName": "jax.value_and_grad",
    "signature": "(fun: 'Callable', argnums: 'Union[int, Sequence[int]]' = 0, has_aux: 'bool' = False, holomorphic: 'bool' = False, allow_int: 'bool' = False, reduce_axes: 'Sequence[AxisName]' = ()) -> 'Callable[..., Tuple[Any, Any]]'",
    "description": "Create a function that evaluates both ``fun`` and the gradient of ``fun``."
  },
  "53": {
    "name": "vjp",
    "module": "jax",
    "fullName": "jax.vjp",
    "signature": "(fun: 'Callable', *primals, has_aux: 'bool' = False, reduce_axes=()) -> 'Union[Tuple[Any, Callable], Tuple[Any, Callable, Any]]'",
    "description": "Compute a (reverse-mode) vector-Jacobian product of ``fun``."
  },
  "54": {
    "name": "vmap",
    "module": "jax",
    "fullName": "jax.vmap",
    "signature": "(fun: 'F', in_axes: 'Union[int, None, Sequence[Any]]' = 0, out_axes: 'Any' = 0, axis_name: 'Optional[AxisName]' = None, axis_size: 'Optional[int]' = None, spmd_axis_name: 'Optional[Union[AxisName, Tuple[AxisName, ...]]]' = None) -> 'F'",
    "description": "Vectorizing map. Creates a function which maps ``fun`` over argument axes."
  },
  "55": {
    "name": "xla_computation",
    "module": "jax",
    "fullName": "jax.xla_computation",
    "signature": "(fun: 'Callable', static_argnums: 'Union[int, Iterable[int]]' = (), axis_env: 'Optional[Sequence[Tuple[AxisName, int]]]' = None, in_parts=None, out_parts=None, backend: 'Optional[str]' = None, tuple_args: 'bool' = False, instantiate_const_outputs: 'Optional[bool]' = None, return_shape: 'bool' = False, donate_argnums: 'Union[int, Iterable[int]]' = ()) -> 'Callable'",
    "description": "Creates a function that produces its XLA computation given example args."
  },
  "56": {
    "name": "as_hashable_function",
    "module": "jax.util",
    "fullName": "jax.util.as_hashable_function",
    "signature": "(closure)",
    "description": "No description available."
  },
  "57": {
    "name": "cache",
    "module": "jax.util",
    "fullName": "jax.util.cache",
    "signature": "(max_size=4096)",
    "description": "No description available."
  },
  "58": {
    "name": "split_dict",
    "module": "jax.util",
    "fullName": "jax.util.split_dict",
    "signature": "(dct, names)",
    "description": "No description available."
  },
  "59": {
    "name": "split_list",
    "module": "jax.util",
    "fullName": "jax.util.split_list",
    "signature": "(args: Sequence[~T], ns: Sequence[int]) -> List[List[~T]]",
    "description": "No description available."
  },
  "60": {
    "name": "split_merge",
    "module": "jax.util",
    "fullName": "jax.util.split_merge",
    "signature": "(predicate, xs)",
    "description": "No description available."
  },
  "61": {
    "name": "subvals",
    "module": "jax.util",
    "fullName": "jax.util.subvals",
    "signature": "(lst, replace)",
    "description": "No description available."
  },
  "62": {
    "name": "toposort",
    "module": "jax.util",
    "fullName": "jax.util.toposort",
    "signature": "(end_nodes)",
    "description": "No description available."
  },
  "63": {
    "name": "unzip2",
    "module": "jax.util",
    "fullName": "jax.util.unzip2",
    "signature": "(xys: Iterable[Tuple[~T1, ~T2]]) -> Tuple[Tuple[~T1, ...], Tuple[~T2, ...]]",
    "description": "Unzip sequence of length-2 tuples into two tuples."
  },
  "64": {
    "name": "wrap_name",
    "module": "jax.util",
    "fullName": "jax.util.wrap_name",
    "signature": "(name, transform_name)",
    "description": "No description available."
  },
  "65": {
    "name": "wraps",
    "module": "jax.util",
    "fullName": "jax.util.wraps",
    "signature": "(wrapped: Callable, namestr: Optional[str] = None, docstr: Optional[str] = None, **kwargs) -> Callable[[~T], ~T]",
    "description": "Like functools.wraps, but with finer-grained control over the name and docstring"
  },
  "66": {
    "name": "ArrayLike",
    "module": "jax.typing",
    "fullName": "jax.typing.ArrayLike",
    "signature": "(*args, **kwargs)",
    "description": "Type annotation for JAX array-like objects."
  },
  "67": {
    "name": "all_leaves",
    "module": "jax.tree_util",
    "fullName": "jax.tree_util.all_leaves",
    "signature": "(iterable: 'Iterable[Any]', is_leaf: 'Optional[Callable[[Any], bool]]' = None) -> 'bool'",
    "description": "Tests whether all elements in the given iterable are all leaves."
  },
  "68": {
    "name": "build_tree",
    "module": "jax.tree_util",
    "fullName": "jax.tree_util.build_tree",
    "signature": "(treedef: 'PyTreeDef', xs: 'Any') -> 'Any'",
    "description": "No description available."
  },
  "69": {
    "name": "keystr",
    "module": "jax.tree_util",
    "fullName": "jax.tree_util.keystr",
    "signature": "(keys: 'KeyPath')",
    "description": "Helper to pretty-print a tuple of keys."
  },
  "70": {
    "name": "register_keypaths",
    "module": "jax.tree_util",
    "fullName": "jax.tree_util.register_keypaths",
    "signature": "(ty: 'Type[T]', handler: 'Callable[[T], Tuple[KeyEntry, ...]]') -> 'None'",
    "description": "[Deprecated] Register the method to get keypaths for type."
  },
  "71": {
    "name": "register_pytree_node",
    "module": "jax.tree_util",
    "fullName": "jax.tree_util.register_pytree_node",
    "signature": "(nodetype: 'Type[T]', flatten_func: 'Callable[[T], Tuple[_Children, _AuxData]]', unflatten_func: 'Callable[[_AuxData, _Children], T]')",
    "description": "Extends the set of types that are considered internal nodes in pytrees."
  },
  "72": {
    "name": "register_pytree_node_class",
    "module": "jax.tree_util",
    "fullName": "jax.tree_util.register_pytree_node_class",
    "signature": "(cls: 'U') -> 'U'",
    "description": "Extends the set of types that are considered internal nodes in pytrees."
  },
  "73": {
    "name": "register_pytree_with_keys",
    "module": "jax.tree_util",
    "fullName": "jax.tree_util.register_pytree_with_keys",
    "signature": "(nodetype: 'Type[T]', flatten_with_keys: 'Callable[[T], Tuple[Iterable[Tuple[KeyEntry, Any]], _AuxData]]', unflatten_func: 'Callable[[_AuxData, Iterable[Any]], T]', flatten_func: 'Optional[Callable[[T], Tuple[Iterable[Any], _AuxData]]]' = None)",
    "description": "Extends the set of types that are considered internal nodes in pytrees."
  },
  "74": {
    "name": "register_pytree_with_keys_class",
    "module": "jax.tree_util",
    "fullName": "jax.tree_util.register_pytree_with_keys_class",
    "signature": "(cls: 'U') -> 'U'",
    "description": "Extends the set of types that are considered internal nodes in pytrees."
  },
  "75": {
    "name": "tree_all",
    "module": "jax.tree_util",
    "fullName": "jax.tree_util.tree_all",
    "signature": "(tree: 'Any') -> 'bool'",
    "description": "No description available."
  },
  "76": {
    "name": "tree_flatten",
    "module": "jax.tree_util",
    "fullName": "jax.tree_util.tree_flatten",
    "signature": "(tree: 'Any', is_leaf: 'Optional[Callable[[Any], bool]]' = None) -> 'Tuple[List[Leaf], PyTreeDef]'",
    "description": "Flattens a pytree."
  },
  "77": {
    "name": "tree_flatten_with_path",
    "module": "jax.tree_util",
    "fullName": "jax.tree_util.tree_flatten_with_path",
    "signature": "(tree: 'Any', is_leaf: 'Optional[Callable[[Any], bool]]' = None) -> 'Tuple[List[Tuple[KeyPath, Any]], PyTreeDef]'",
    "description": "Flattens a pytree like ``tree_flatten``, but also returns each leaf's key path."
  },
  "78": {
    "name": "tree_leaves",
    "module": "jax.tree_util",
    "fullName": "jax.tree_util.tree_leaves",
    "signature": "(tree: 'Any', is_leaf: 'Optional[Callable[[Any], bool]]' = None) -> 'List[Leaf]'",
    "description": "Gets the leaves of a pytree."
  },
  "79": {
    "name": "tree_leaves_with_path",
    "module": "jax.tree_util",
    "fullName": "jax.tree_util.tree_leaves_with_path",
    "signature": "(tree: 'Any', is_leaf: 'Optional[Callable[[Any], bool]]' = None) -> 'List[Tuple[KeyPath, Any]]'",
    "description": "Gets the leaves of a pytree like ``tree_leaves`` and returns each leaf's key path."
  },
  "80": {
    "name": "tree_map",
    "module": "jax.tree_util",
    "fullName": "jax.tree_util.tree_map",
    "signature": "(f: 'Callable[..., Any]', tree: 'Any', *rest: 'Any', is_leaf: 'Optional[Callable[[Any], bool]]' = None) -> 'Any'",
    "description": "Maps a multi-input function over pytree args to produce a new pytree."
  },
  "81": {
    "name": "tree_map_with_path",
    "module": "jax.tree_util",
    "fullName": "jax.tree_util.tree_map_with_path",
    "signature": "(f: 'Callable[..., Any]', tree: 'Any', *rest: 'Any', is_leaf: 'Optional[Callable[[Any], bool]]' = None) -> 'Any'",
    "description": "Maps a multi-input function over pytree key path and args to produce a new pytree."
  },
  "82": {
    "name": "tree_reduce",
    "module": "jax.tree_util",
    "fullName": "jax.tree_util.tree_reduce",
    "signature": "(function: 'Callable[[T, Any], T]', tree: 'Any', initializer: 'Any' = <object object at 0x00000267B2BE0220>, is_leaf: 'Optional[Callable[[Any], bool]]' = None) -> 'T'",
    "description": "No description available."
  },
  "83": {
    "name": "tree_structure",
    "module": "jax.tree_util",
    "fullName": "jax.tree_util.tree_structure",
    "signature": "(tree: 'Any', is_leaf: 'Optional[Callable[[Any], bool]]' = None) -> 'PyTreeDef'",
    "description": "Gets the treedef for a pytree."
  },
  "84": {
    "name": "tree_transpose",
    "module": "jax.tree_util",
    "fullName": "jax.tree_util.tree_transpose",
    "signature": "(outer_treedef: 'PyTreeDef', inner_treedef: 'PyTreeDef', pytree_to_transpose: 'Any') -> 'Any'",
    "description": "Transform a tree having tree structure (outer, inner) into one having structure"
  },
  "85": {
    "name": "tree_unflatten",
    "module": "jax.tree_util",
    "fullName": "jax.tree_util.tree_unflatten",
    "signature": "(treedef: 'PyTreeDef', leaves: 'Iterable[Leaf]') -> 'Any'",
    "description": "Reconstructs a pytree from the treedef and the leaves."
  },
  "86": {
    "name": "treedef_children",
    "module": "jax.tree_util",
    "fullName": "jax.tree_util.treedef_children",
    "signature": "(treedef: 'PyTreeDef') -> 'List[PyTreeDef]'",
    "description": "No description available."
  },
  "87": {
    "name": "treedef_is_leaf",
    "module": "jax.tree_util",
    "fullName": "jax.tree_util.treedef_is_leaf",
    "signature": "(treedef: 'PyTreeDef') -> 'bool'",
    "description": "No description available."
  },
  "88": {
    "name": "treedef_tuple",
    "module": "jax.tree_util",
    "fullName": "jax.tree_util.treedef_tuple",
    "signature": "(treedefs: 'Iterable[PyTreeDef]') -> 'PyTreeDef'",
    "description": "Makes a tuple treedef from an iterable of child treedefs."
  },
  "89": {
    "name": "bessel_jn",
    "module": "jax.scipy.special",
    "fullName": "jax.scipy.special.bessel_jn",
    "signature": "(z: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], *, v: int, n_iter: int = 50) -> jax.Array",
    "description": "Bessel function of the first kind of integer order and real argument."
  },
  "90": {
    "name": "betainc",
    "module": "jax.scipy.special",
    "fullName": "jax.scipy.special.betainc",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], b: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Regularized incomplete beta function."
  },
  "91": {
    "name": "betaln",
    "module": "jax.scipy.special",
    "fullName": "jax.scipy.special.betaln",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], b: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Natural logarithm of absolute value of beta function."
  },
  "92": {
    "name": "digamma",
    "module": "jax.scipy.special",
    "fullName": "jax.scipy.special.digamma",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "The digamma function."
  },
  "93": {
    "name": "entr",
    "module": "jax.scipy.special",
    "fullName": "jax.scipy.special.entr",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise function for computing entropy."
  },
  "94": {
    "name": "erf",
    "module": "jax.scipy.special",
    "fullName": "jax.scipy.special.erf",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Returns the error function of complex argument."
  },
  "95": {
    "name": "erfc",
    "module": "jax.scipy.special",
    "fullName": "jax.scipy.special.erfc",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Complementary error function, ``1 - erf(x)``."
  },
  "96": {
    "name": "erfinv",
    "module": "jax.scipy.special",
    "fullName": "jax.scipy.special.erfinv",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Inverse of the error function."
  },
  "97": {
    "name": "exp1",
    "module": "jax.scipy.special",
    "fullName": "jax.scipy.special.exp1",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], module='scipy.special') -> jax.Array",
    "description": "Exponential integral E1."
  },
  "98": {
    "name": "expit",
    "module": "jax.scipy.special",
    "fullName": "jax.scipy.special.expit",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Expit (a.k.a. logistic sigmoid) ufunc for ndarrays."
  },
  "99": {
    "name": "gamma",
    "module": "jax.scipy.special",
    "fullName": "jax.scipy.special.gamma",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "gamma function."
  },
  "100": {
    "name": "gammainc",
    "module": "jax.scipy.special",
    "fullName": "jax.scipy.special.gammainc",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Regularized lower incomplete gamma function."
  },
  "101": {
    "name": "gammaincc",
    "module": "jax.scipy.special",
    "fullName": "jax.scipy.special.gammaincc",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Regularized upper incomplete gamma function."
  },
  "102": {
    "name": "gammaln",
    "module": "jax.scipy.special",
    "fullName": "jax.scipy.special.gammaln",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Logarithm of the absolute value of the gamma function."
  },
  "103": {
    "name": "i0",
    "module": "jax.scipy.special",
    "fullName": "jax.scipy.special.i0",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Modified Bessel function of order 0."
  },
  "104": {
    "name": "i0e",
    "module": "jax.scipy.special",
    "fullName": "jax.scipy.special.i0e",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Exponentially scaled modified Bessel function of order 0."
  },
  "105": {
    "name": "i1",
    "module": "jax.scipy.special",
    "fullName": "jax.scipy.special.i1",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Modified Bessel function of order 1."
  },
  "106": {
    "name": "i1e",
    "module": "jax.scipy.special",
    "fullName": "jax.scipy.special.i1e",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Exponentially scaled modified Bessel function of order 1."
  },
  "107": {
    "name": "logsumexp",
    "module": "jax.scipy.special",
    "fullName": "jax.scipy.special.logsumexp",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], axis: Optional[int] = None, b: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, NoneType] = None, keepdims: bool = False, return_sign: bool = False) -> Union[jax.Array, Tuple[jax.Array, jax.Array]]",
    "description": "Compute the log of the sum of exponentials of input elements."
  },
  "108": {
    "name": "lpmn",
    "module": "jax.scipy.special",
    "fullName": "jax.scipy.special.lpmn",
    "signature": "(m: int, n: int, z: jax.Array) -> Tuple[jax.Array, jax.Array]",
    "description": "The associated Legendre functions (ALFs) of the first kind."
  },
  "109": {
    "name": "lpmn_values",
    "module": "jax.scipy.special",
    "fullName": "jax.scipy.special.lpmn_values",
    "signature": "(m: int, n: int, z: jax.Array, is_normalized: bool) -> jax.Array",
    "description": "The associated Legendre functions (ALFs) of the first kind."
  },
  "110": {
    "name": "multigammaln",
    "module": "jax.scipy.special",
    "fullName": "jax.scipy.special.multigammaln",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], d: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Returns the log of multivariate gamma, also sometimes called the"
  },
  "111": {
    "name": "ndtr",
    "module": "jax.scipy.special",
    "fullName": "jax.scipy.special.ndtr",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Normal distribution function."
  },
  "112": {
    "name": "ndtri",
    "module": "jax.scipy.special",
    "fullName": "jax.scipy.special.ndtri",
    "signature": "(p: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "The inverse of the CDF of the Normal distribution function."
  },
  "113": {
    "name": "polygamma",
    "module": "jax.scipy.special",
    "fullName": "jax.scipy.special.polygamma",
    "signature": "(n: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Polygamma functions."
  },
  "114": {
    "name": "spence",
    "module": "jax.scipy.special",
    "fullName": "jax.scipy.special.spence",
    "signature": "(x: jax.Array) -> jax.Array",
    "description": "Spence's function, also known as the dilogarithm for real values."
  },
  "115": {
    "name": "sph_harm",
    "module": "jax.scipy.special",
    "fullName": "jax.scipy.special.sph_harm",
    "signature": "(m: jax.Array, n: jax.Array, theta: jax.Array, phi: jax.Array, n_max: Optional[int] = None) -> jax.Array",
    "description": "Computes the spherical harmonics."
  },
  "116": {
    "name": "zeta",
    "module": "jax.scipy.special",
    "fullName": "jax.scipy.special.zeta",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], q: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, NoneType] = None) -> jax.Array",
    "description": "Riemann or Hurwitz zeta function."
  },
  "117": {
    "name": "bicgstab",
    "module": "jax.scipy.sparse.linalg",
    "fullName": "jax.scipy.sparse.linalg.bicgstab",
    "signature": "(A, b, x0=None, *, tol=1e-05, atol=0.0, maxiter=None, M=None)",
    "description": "Use Bi-Conjugate Gradient Stable iteration to solve ``Ax = b``."
  },
  "118": {
    "name": "cg",
    "module": "jax.scipy.sparse.linalg",
    "fullName": "jax.scipy.sparse.linalg.cg",
    "signature": "(A, b, x0=None, *, tol=1e-05, atol=0.0, maxiter=None, M=None)",
    "description": "Use Conjugate Gradient iteration to solve ``Ax = b``."
  },
  "119": {
    "name": "gmres",
    "module": "jax.scipy.sparse.linalg",
    "fullName": "jax.scipy.sparse.linalg.gmres",
    "signature": "(A, b, x0=None, *, tol=1e-05, atol=0.0, restart=20, maxiter=None, M=None, solve_method='batched')",
    "description": "GMRES solves the linear system A x = b for x, given A and b."
  },
  "120": {
    "name": "convolve",
    "module": "jax.scipy.signal",
    "fullName": "jax.scipy.signal.convolve",
    "signature": "(in1: jax.Array, in2: jax.Array, mode: str = 'full', method: str = 'auto', precision: Union[NoneType, str, jax._src.lax.lax.Precision, Tuple[str, str], Tuple[jax._src.lax.lax.Precision, jax._src.lax.lax.Precision]] = None) -> jax.Array",
    "description": "Convolve two N-dimensional arrays."
  },
  "121": {
    "name": "convolve2d",
    "module": "jax.scipy.signal",
    "fullName": "jax.scipy.signal.convolve2d",
    "signature": "(in1: jax.Array, in2: jax.Array, mode: str = 'full', boundary: str = 'fill', fillvalue: float = 0, precision: Union[NoneType, str, jax._src.lax.lax.Precision, Tuple[str, str], Tuple[jax._src.lax.lax.Precision, jax._src.lax.lax.Precision]] = None) -> jax.Array",
    "description": "Convolve two 2-dimensional arrays."
  },
  "122": {
    "name": "correlate",
    "module": "jax.scipy.signal",
    "fullName": "jax.scipy.signal.correlate",
    "signature": "(in1: jax.Array, in2: jax.Array, mode: str = 'full', method: str = 'auto', precision: Union[NoneType, str, jax._src.lax.lax.Precision, Tuple[str, str], Tuple[jax._src.lax.lax.Precision, jax._src.lax.lax.Precision]] = None) -> jax.Array",
    "description": "Cross-correlate two N-dimensional arrays."
  },
  "123": {
    "name": "correlate2d",
    "module": "jax.scipy.signal",
    "fullName": "jax.scipy.signal.correlate2d",
    "signature": "(in1: jax.Array, in2: jax.Array, mode: str = 'full', boundary: str = 'fill', fillvalue: float = 0, precision: Union[NoneType, str, jax._src.lax.lax.Precision, Tuple[str, str], Tuple[jax._src.lax.lax.Precision, jax._src.lax.lax.Precision]] = None) -> jax.Array",
    "description": "Cross-correlate two 2-dimensional arrays."
  },
  "124": {
    "name": "csd",
    "module": "jax.scipy.signal",
    "fullName": "jax.scipy.signal.csd",
    "signature": "(x: jax.Array, y: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, NoneType], fs: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex] = 1.0, window: str = 'hann', nperseg: Optional[int] = None, noverlap: Optional[int] = None, nfft: Optional[int] = None, detrend: str = 'constant', return_onesided: bool = True, scaling: str = 'density', axis: int = -1, average: str = 'mean') -> Tuple[jax.Array, jax.Array]",
    "description": "Estimate the cross power spectral density, Pxy, using Welch's method."
  },
  "125": {
    "name": "detrend",
    "module": "jax.scipy.signal",
    "fullName": "jax.scipy.signal.detrend",
    "signature": "(data: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], axis: int = -1, type: str = 'linear', bp: int = 0, overwrite_data: None = None) -> jax.Array",
    "description": "Remove linear trend along axis from data."
  },
  "126": {
    "name": "fftconvolve",
    "module": "jax.scipy.signal",
    "fullName": "jax.scipy.signal.fftconvolve",
    "signature": "(in1: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], in2: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], mode: str = 'full', axes: Optional[Sequence[int]] = None) -> jax.Array",
    "description": "Convolve two N-dimensional arrays using FFT."
  },
  "127": {
    "name": "istft",
    "module": "jax.scipy.signal",
    "fullName": "jax.scipy.signal.istft",
    "signature": "(Zxx: jax.Array, fs: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex] = 1.0, window: str = 'hann', nperseg: Optional[int] = None, noverlap: Optional[int] = None, nfft: Optional[int] = None, input_onesided: bool = True, boundary: bool = True, time_axis: int = -1, freq_axis: int = -2) -> Tuple[jax.Array, jax.Array]",
    "description": "Perform the inverse Short Time Fourier transform (legacy function)."
  },
  "128": {
    "name": "stft",
    "module": "jax.scipy.signal",
    "fullName": "jax.scipy.signal.stft",
    "signature": "(x: jax.Array, fs: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex] = 1.0, window: str = 'hann', nperseg: int = 256, noverlap: Optional[int] = None, nfft: Optional[int] = None, detrend: bool = False, return_onesided: bool = True, boundary: Optional[str] = 'zeros', padded: bool = True, axis: int = -1) -> Tuple[jax.Array, jax.Array, jax.Array]",
    "description": "Compute the Short Time Fourier Transform (legacy function)."
  },
  "129": {
    "name": "welch",
    "module": "jax.scipy.signal",
    "fullName": "jax.scipy.signal.welch",
    "signature": "(x: jax.Array, fs: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex] = 1.0, window: str = 'hann', nperseg: Optional[int] = None, noverlap: Optional[int] = None, nfft: Optional[int] = None, detrend: str = 'constant', return_onesided: bool = True, scaling: str = 'density', axis: int = -1, average: str = 'mean') -> Tuple[jax.Array, jax.Array]",
    "description": "Estimate power spectral density using Welch's method."
  },
  "130": {
    "name": "map_coordinates",
    "module": "jax.scipy.ndimage",
    "fullName": "jax.scipy.ndimage.map_coordinates",
    "signature": "(input: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], coordinates: Sequence[Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]], order: int, mode: str = 'constant', cval: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex] = 0.0)",
    "description": "Map the input array to new coordinates by interpolation."
  },
  "131": {
    "name": "dct",
    "module": "jax.scipy.fft",
    "fullName": "jax.scipy.fft.dct",
    "signature": "(x: jax.Array, type: int = 2, n: Optional[int] = None, axis: int = -1, norm: Optional[str] = None) -> jax.Array",
    "description": "Return the Discrete Cosine Transform of arbitrary type sequence x."
  },
  "132": {
    "name": "dctn",
    "module": "jax.scipy.fft",
    "fullName": "jax.scipy.fft.dctn",
    "signature": "(x: jax.Array, type: int = 2, s: Optional[Sequence[int]] = None, axes: Optional[Sequence[int]] = None, norm: Optional[str] = None) -> jax.Array",
    "description": "Return multidimensional Discrete Cosine Transform along the specified axes."
  },
  "133": {
    "name": "idct",
    "module": "jax.scipy.fft",
    "fullName": "jax.scipy.fft.idct",
    "signature": "(x: jax.Array, type: int = 2, n: Optional[int] = None, axis: int = -1, norm: Optional[str] = None) -> jax.Array",
    "description": "Return the Discrete Cosine Transform of arbitrary type sequence x."
  },
  "134": {
    "name": "idctn",
    "module": "jax.scipy.fft",
    "fullName": "jax.scipy.fft.idctn",
    "signature": "(x: jax.Array, type: int = 2, s: Optional[Sequence[int]] = None, axes: Optional[Sequence[int]] = None, norm: Optional[str] = None) -> jax.Array",
    "description": "Return multidimensional Inverse Discrete Cosine Transform along the specified axes."
  },
  "135": {
    "name": "vq",
    "module": "jax.scipy.cluster.vq",
    "fullName": "jax.scipy.cluster.vq.vq",
    "signature": "(obs, code_book, check_finite=True)",
    "description": "Assign codes from a code book to observations."
  },
  "136": {
    "name": "PRNGKey",
    "module": "jax.random",
    "fullName": "jax.random.PRNGKey",
    "signature": "(seed: Union[int, jax.Array]) -> Union[jax.Array, jax._src.prng.PRNGKeyArray]",
    "description": "Create a pseudo-random number generator (PRNG) key given an integer seed."
  },
  "137": {
    "name": "ball",
    "module": "jax.random",
    "fullName": "jax.random.ball",
    "signature": "(key: Union[jax.Array, jax._src.prng.PRNGKeyArray], d: int, p: float = 2, shape: Sequence[int] = (), dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType] = <class 'numpy.float64'>)",
    "description": "Sample uniformly from the unit Lp ball."
  },
  "138": {
    "name": "bernoulli",
    "module": "jax.random",
    "fullName": "jax.random.bernoulli",
    "signature": "(key: Union[jax.Array, jax._src.prng.PRNGKeyArray], p: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex] = 0.5, shape: Union[Sequence[int], jax._src.core.NamedShape, NoneType] = None) -> jax.Array",
    "description": "Sample Bernoulli random values with given shape and mean."
  },
  "139": {
    "name": "beta",
    "module": "jax.random",
    "fullName": "jax.random.beta",
    "signature": "(key: Union[jax.Array, jax._src.prng.PRNGKeyArray], a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], b: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], shape: Optional[Sequence[int]] = None, dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType] = <class 'numpy.float64'>) -> jax.Array",
    "description": "Sample Beta random values with given shape and float dtype."
  },
  "140": {
    "name": "bits",
    "module": "jax.random",
    "fullName": "jax.random.bits",
    "signature": "(key: Union[jax.Array, jax._src.prng.PRNGKeyArray], shape: Sequence[int] = (), dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType, NoneType] = None) -> jax.Array",
    "description": "Sample uniform bits in the form of unsigned integers."
  },
  "141": {
    "name": "categorical",
    "module": "jax.random",
    "fullName": "jax.random.categorical",
    "signature": "(key: Union[jax.Array, jax._src.prng.PRNGKeyArray], logits: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], axis: int = -1, shape: Optional[Sequence[int]] = None) -> jax.Array",
    "description": "Sample random values from categorical distributions."
  },
  "142": {
    "name": "cauchy",
    "module": "jax.random",
    "fullName": "jax.random.cauchy",
    "signature": "(key: Union[jax.Array, jax._src.prng.PRNGKeyArray], shape: Sequence[int] = (), dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType] = <class 'numpy.float64'>) -> jax.Array",
    "description": "Sample Cauchy random values with given shape and float dtype."
  },
  "143": {
    "name": "chisquare",
    "module": "jax.random",
    "fullName": "jax.random.chisquare",
    "signature": "(key: Union[jax.Array, jax._src.prng.PRNGKeyArray], df: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], shape: Optional[Sequence[int]] = None, dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType] = <class 'numpy.float64'>) -> jax.Array",
    "description": "Sample Chisquare random values with given shape and float dtype."
  },
  "144": {
    "name": "choice",
    "module": "jax.random",
    "fullName": "jax.random.choice",
    "signature": "(key: Union[jax.Array, jax._src.prng.PRNGKeyArray], a: Union[int, jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, float, complex], shape: Sequence[int] = (), replace: bool = True, p: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, NoneType] = None, axis: int = 0) -> jax.Array",
    "description": "Generates a random sample from a given array."
  },
  "145": {
    "name": "default_prng_impl",
    "module": "jax.random",
    "fullName": "jax.random.default_prng_impl",
    "signature": "()",
    "description": "Get the default PRNG implementation."
  },
  "146": {
    "name": "dirichlet",
    "module": "jax.random",
    "fullName": "jax.random.dirichlet",
    "signature": "(key: Union[jax.Array, jax._src.prng.PRNGKeyArray], alpha: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], shape: Optional[Sequence[int]] = None, dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType] = <class 'numpy.float64'>) -> jax.Array",
    "description": "Sample Dirichlet random values with given shape and float dtype."
  },
  "147": {
    "name": "double_sided_maxwell",
    "module": "jax.random",
    "fullName": "jax.random.double_sided_maxwell",
    "signature": "(key: Union[jax.Array, jax._src.prng.PRNGKeyArray], loc: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], scale: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], shape: Sequence[int] = (), dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType] = <class 'numpy.float64'>) -> jax.Array",
    "description": "Sample from a double sided Maxwell distribution."
  },
  "148": {
    "name": "exponential",
    "module": "jax.random",
    "fullName": "jax.random.exponential",
    "signature": "(key: Union[jax.Array, jax._src.prng.PRNGKeyArray], shape: Sequence[int] = (), dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType] = <class 'numpy.float64'>) -> jax.Array",
    "description": "Sample Exponential random values with given shape and float dtype."
  },
  "149": {
    "name": "f",
    "module": "jax.random",
    "fullName": "jax.random.f",
    "signature": "(key: Union[jax.Array, jax._src.prng.PRNGKeyArray], dfnum: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], dfden: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], shape: Optional[Sequence[int]] = None, dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType] = <class 'numpy.float64'>) -> jax.Array",
    "description": "Sample F-distribution random values with given shape and float dtype."
  },
  "150": {
    "name": "fold_in",
    "module": "jax.random",
    "fullName": "jax.random.fold_in",
    "signature": "(key: Union[jax.Array, jax._src.prng.PRNGKeyArray], data: int) -> Union[jax.Array, jax._src.prng.PRNGKeyArray]",
    "description": "Folds in data to a PRNG key to form a new PRNG key."
  },
  "151": {
    "name": "gamma",
    "module": "jax.random",
    "fullName": "jax.random.gamma",
    "signature": "(key: Union[jax.Array, jax._src.prng.PRNGKeyArray], a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], shape: Optional[Sequence[int]] = None, dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType] = <class 'numpy.float64'>) -> jax.Array",
    "description": "Sample Gamma random values with given shape and float dtype."
  },
  "152": {
    "name": "generalized_normal",
    "module": "jax.random",
    "fullName": "jax.random.generalized_normal",
    "signature": "(key: Union[jax.Array, jax._src.prng.PRNGKeyArray], p: float, shape: Sequence[int] = (), dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType] = <class 'numpy.float64'>) -> jax.Array",
    "description": "Sample from the generalized normal distribution."
  },
  "153": {
    "name": "geometric",
    "module": "jax.random",
    "fullName": "jax.random.geometric",
    "signature": "(key: Union[jax.Array, jax._src.prng.PRNGKeyArray], p: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], shape: Optional[Sequence[int]] = None, dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType] = <class 'numpy.int64'>) -> jax.Array",
    "description": "Sample Geometric random values with given shape and float dtype."
  },
  "154": {
    "name": "gumbel",
    "module": "jax.random",
    "fullName": "jax.random.gumbel",
    "signature": "(key: Union[jax.Array, jax._src.prng.PRNGKeyArray], shape: Sequence[int] = (), dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType] = <class 'numpy.float64'>) -> jax.Array",
    "description": "Sample Gumbel random values with given shape and float dtype."
  },
  "155": {
    "name": "key",
    "module": "jax.random",
    "fullName": "jax.random.key",
    "signature": "(seed: Union[int, jax.Array]) -> jax._src.prng.PRNGKeyArray",
    "description": "Create a pseudo-random number generator (PRNG) key given an integer seed."
  },
  "156": {
    "name": "key_data",
    "module": "jax.random",
    "fullName": "jax.random.key_data",
    "signature": "(keys: Union[jax.Array, jax._src.prng.PRNGKeyArray]) -> jax.Array",
    "description": "No description available."
  },
  "157": {
    "name": "laplace",
    "module": "jax.random",
    "fullName": "jax.random.laplace",
    "signature": "(key: Union[jax.Array, jax._src.prng.PRNGKeyArray], shape: Sequence[int] = (), dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType] = <class 'numpy.float64'>) -> jax.Array",
    "description": "Sample Laplace random values with given shape and float dtype."
  },
  "158": {
    "name": "loggamma",
    "module": "jax.random",
    "fullName": "jax.random.loggamma",
    "signature": "(key: Union[jax.Array, jax._src.prng.PRNGKeyArray], a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], shape: Optional[Sequence[int]] = None, dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType] = <class 'numpy.float64'>) -> jax.Array",
    "description": "Sample log-gamma random values with given shape and float dtype."
  },
  "159": {
    "name": "logistic",
    "module": "jax.random",
    "fullName": "jax.random.logistic",
    "signature": "(key: Union[jax.Array, jax._src.prng.PRNGKeyArray], shape: Sequence[int] = (), dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType] = <class 'numpy.float64'>) -> jax.Array",
    "description": "Sample logistic random values with given shape and float dtype."
  },
  "160": {
    "name": "maxwell",
    "module": "jax.random",
    "fullName": "jax.random.maxwell",
    "signature": "(key: Union[jax.Array, jax._src.prng.PRNGKeyArray], shape: Sequence[int] = (), dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType] = <class 'numpy.float64'>) -> jax.Array",
    "description": "Sample from a one sided Maxwell distribution."
  },
  "161": {
    "name": "multivariate_normal",
    "module": "jax.random",
    "fullName": "jax.random.multivariate_normal",
    "signature": "(key: Union[jax.Array, jax._src.prng.PRNGKeyArray], mean: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], cov: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], shape: Optional[Sequence[int]] = None, dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType] = None, method: str = 'cholesky') -> jax.Array",
    "description": "Sample multivariate normal random values with given mean and covariance."
  },
  "162": {
    "name": "normal",
    "module": "jax.random",
    "fullName": "jax.random.normal",
    "signature": "(key: Union[jax.Array, jax._src.prng.PRNGKeyArray], shape: Union[Sequence[int], jax._src.core.NamedShape] = (), dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType] = <class 'numpy.float64'>) -> jax.Array",
    "description": "Sample standard normal random values with given shape and float dtype."
  },
  "163": {
    "name": "orthogonal",
    "module": "jax.random",
    "fullName": "jax.random.orthogonal",
    "signature": "(key: Union[jax.Array, jax._src.prng.PRNGKeyArray], n: int, shape: Sequence[int] = (), dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType] = <class 'numpy.float64'>) -> jax.Array",
    "description": "Sample uniformly from the orthogonal group O(n)."
  },
  "164": {
    "name": "pareto",
    "module": "jax.random",
    "fullName": "jax.random.pareto",
    "signature": "(key: Union[jax.Array, jax._src.prng.PRNGKeyArray], b: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], shape: Optional[Sequence[int]] = None, dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType] = <class 'numpy.float64'>) -> jax.Array",
    "description": "Sample Pareto random values with given shape and float dtype."
  },
  "165": {
    "name": "permutation",
    "module": "jax.random",
    "fullName": "jax.random.permutation",
    "signature": "(key: Union[jax.Array, jax._src.prng.PRNGKeyArray], x: Union[int, jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, float, complex], axis: int = 0, independent: bool = False) -> jax.Array",
    "description": "Returns a randomly permuted array or range."
  },
  "166": {
    "name": "poisson",
    "module": "jax.random",
    "fullName": "jax.random.poisson",
    "signature": "(key: Union[jax.Array, jax._src.prng.PRNGKeyArray], lam: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], shape: Optional[Sequence[int]] = None, dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType] = <class 'numpy.int64'>) -> jax.Array",
    "description": "Sample Poisson random values with given shape and integer dtype."
  },
  "167": {
    "name": "rademacher",
    "module": "jax.random",
    "fullName": "jax.random.rademacher",
    "signature": "(key: Union[jax.Array, jax._src.prng.PRNGKeyArray], shape: Sequence[int], dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType] = <class 'numpy.int64'>) -> jax.Array",
    "description": "Sample from a Rademacher distribution."
  },
  "168": {
    "name": "randint",
    "module": "jax.random",
    "fullName": "jax.random.randint",
    "signature": "(key: Union[jax.Array, jax._src.prng.PRNGKeyArray], shape: Sequence[int], minval: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], maxval: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType] = <class 'numpy.int64'>) -> jax.Array",
    "description": "Sample uniform random values in [minval, maxval) with given shape/dtype."
  },
  "169": {
    "name": "rayleigh",
    "module": "jax.random",
    "fullName": "jax.random.rayleigh",
    "signature": "(key: Union[jax.Array, jax._src.prng.PRNGKeyArray], scale: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], shape: Optional[Sequence[int]] = None, dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType] = <class 'numpy.float64'>) -> jax.Array",
    "description": "Sample Rayleigh random values with given shape and float dtype."
  },
  "170": {
    "name": "rbg_key",
    "module": "jax.random",
    "fullName": "jax.random.rbg_key",
    "signature": "(seed: int) -> Union[jax.Array, jax._src.prng.PRNGKeyArray]",
    "description": "Creates an RBG PRNG key from an integer seed."
  },
  "171": {
    "name": "shuffle",
    "module": "jax.random",
    "fullName": "jax.random.shuffle",
    "signature": "(key: Union[jax.Array, jax._src.prng.PRNGKeyArray], x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], axis: int = 0) -> jax.Array",
    "description": "Shuffle the elements of an array uniformly at random along an axis."
  },
  "172": {
    "name": "split",
    "module": "jax.random",
    "fullName": "jax.random.split",
    "signature": "(key: Union[jax.Array, jax._src.prng.PRNGKeyArray], num: int = 2) -> Union[jax.Array, jax._src.prng.PRNGKeyArray]",
    "description": "Splits a PRNG key into `num` new keys by adding a leading axis."
  },
  "173": {
    "name": "t",
    "module": "jax.random",
    "fullName": "jax.random.t",
    "signature": "(key: Union[jax.Array, jax._src.prng.PRNGKeyArray], df: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], shape: Sequence[int] = (), dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType] = <class 'numpy.float64'>) -> jax.Array",
    "description": "Sample Student's t random values with given shape and float dtype."
  },
  "174": {
    "name": "threefry2x32_key",
    "module": "jax.random",
    "fullName": "jax.random.threefry2x32_key",
    "signature": "(seed: int) -> Union[jax.Array, jax._src.prng.PRNGKeyArray]",
    "description": "Creates a threefry2x32 PRNG key from an integer seed."
  },
  "175": {
    "name": "threefry_2x32",
    "module": "jax.random",
    "fullName": "jax.random.threefry_2x32",
    "signature": "(keypair, count)",
    "description": "No description available."
  },
  "176": {
    "name": "truncated_normal",
    "module": "jax.random",
    "fullName": "jax.random.truncated_normal",
    "signature": "(key: Union[jax.Array, jax._src.prng.PRNGKeyArray], lower: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], upper: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], shape: Union[Sequence[int], jax._src.core.NamedShape, NoneType] = None, dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType] = <class 'numpy.float64'>) -> jax.Array",
    "description": "Sample truncated standard normal random values with given shape and dtype."
  },
  "177": {
    "name": "uniform",
    "module": "jax.random",
    "fullName": "jax.random.uniform",
    "signature": "(key: Union[jax.Array, jax._src.prng.PRNGKeyArray], shape: Union[Sequence[int], jax._src.core.NamedShape] = (), dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType] = <class 'numpy.float64'>, minval: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex] = 0.0, maxval: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex] = 1.0) -> jax.Array",
    "description": "Sample uniform random values in [minval, maxval) with given shape/dtype."
  },
  "178": {
    "name": "unsafe_rbg_key",
    "module": "jax.random",
    "fullName": "jax.random.unsafe_rbg_key",
    "signature": "(seed: int) -> Union[jax.Array, jax._src.prng.PRNGKeyArray]",
    "description": "Creates an unsafe RBG PRNG key from an integer seed."
  },
  "179": {
    "name": "wald",
    "module": "jax.random",
    "fullName": "jax.random.wald",
    "signature": "(key: Union[jax.Array, jax._src.prng.PRNGKeyArray], mean: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], shape: Optional[Sequence[int]] = None, dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType] = <class 'numpy.float64'>) -> jax.Array",
    "description": "Sample Wald random values with given shape and float dtype."
  },
  "180": {
    "name": "weibull_min",
    "module": "jax.random",
    "fullName": "jax.random.weibull_min",
    "signature": "(key: Union[jax.Array, jax._src.prng.PRNGKeyArray], scale: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], concentration: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], shape: Sequence[int] = (), dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType] = <class 'numpy.float64'>) -> jax.Array",
    "description": "Sample from a Weibull distribution."
  },
  "181": {
    "name": "NamedTuple",
    "module": "jax.random.typing",
    "fullName": "jax.random.typing.NamedTuple",
    "signature": "(typename, fields=None, /, **kwargs)",
    "description": "Typed version of namedtuple."
  },
  "182": {
    "name": "NewType",
    "module": "jax.random.typing",
    "fullName": "jax.random.typing.NewType",
    "signature": "(name, tp)",
    "description": "NewType creates simple unique types with almost zero"
  },
  "183": {
    "name": "TypedDict",
    "module": "jax.random.typing",
    "fullName": "jax.random.typing.TypedDict",
    "signature": "(typename, fields=None, /, *, total=True, **kwargs)",
    "description": "A simple typed namespace. At runtime it is equivalent to a plain dict."
  },
  "184": {
    "name": "abstractmethod",
    "module": "jax.random.typing",
    "fullName": "jax.random.typing.abstractmethod",
    "signature": "(funcobj)",
    "description": "A decorator indicating abstract methods."
  },
  "185": {
    "name": "cast",
    "module": "jax.random.typing",
    "fullName": "jax.random.typing.cast",
    "signature": "(typ, val)",
    "description": "Cast a value to a type."
  },
  "186": {
    "name": "final",
    "module": "jax.random.typing",
    "fullName": "jax.random.typing.final",
    "signature": "(f)",
    "description": "A decorator to indicate final methods and final classes."
  },
  "187": {
    "name": "get_args",
    "module": "jax.random.typing",
    "fullName": "jax.random.typing.get_args",
    "signature": "(tp)",
    "description": "Get type arguments with all substitutions performed."
  },
  "188": {
    "name": "get_origin",
    "module": "jax.random.typing",
    "fullName": "jax.random.typing.get_origin",
    "signature": "(tp)",
    "description": "Get the unsubscripted version of a type."
  },
  "189": {
    "name": "get_type_hints",
    "module": "jax.random.typing",
    "fullName": "jax.random.typing.get_type_hints",
    "signature": "(obj, globalns=None, localns=None, include_extras=False)",
    "description": "Return type hints for an object."
  },
  "190": {
    "name": "no_type_check",
    "module": "jax.random.typing",
    "fullName": "jax.random.typing.no_type_check",
    "signature": "(arg)",
    "description": "Decorator to indicate that annotations are not type hints."
  },
  "191": {
    "name": "no_type_check_decorator",
    "module": "jax.random.typing",
    "fullName": "jax.random.typing.no_type_check_decorator",
    "signature": "(decorator)",
    "description": "Decorator to give another decorator the @no_type_check effect."
  },
  "192": {
    "name": "overload",
    "module": "jax.random.typing",
    "fullName": "jax.random.typing.overload",
    "signature": "(func)",
    "description": "Decorator for overloaded functions/methods."
  },
  "193": {
    "name": "runtime_checkable",
    "module": "jax.random.typing",
    "fullName": "jax.random.typing.runtime_checkable",
    "signature": "(cls)",
    "description": "Mark a protocol class as a runtime protocol."
  },
  "194": {
    "name": "coroutine",
    "module": "jax.random.typing.types",
    "fullName": "jax.random.typing.types.coroutine",
    "signature": "(func)",
    "description": "Convert regular generator function to a coroutine."
  },
  "195": {
    "name": "new_class",
    "module": "jax.random.typing.types",
    "fullName": "jax.random.typing.types.new_class",
    "signature": "(name, bases=(), kwds=None, exec_body=None)",
    "description": "Create a class object dynamically using the appropriate metaclass."
  },
  "196": {
    "name": "prepare_class",
    "module": "jax.random.typing.types",
    "fullName": "jax.random.typing.types.prepare_class",
    "signature": "(name, bases=(), kwds=None)",
    "description": "Call the __prepare__ method of the appropriate metaclass."
  },
  "197": {
    "name": "resolve_bases",
    "module": "jax.random.typing.types",
    "fullName": "jax.random.typing.types.resolve_bases",
    "signature": "(bases)",
    "description": "Resolve MRO entries dynamically as specified by PEP 560."
  },
  "198": {
    "name": "compile",
    "module": "jax.random.typing.stdlib_re",
    "fullName": "jax.random.typing.stdlib_re.compile",
    "signature": "(pattern, flags=0)",
    "description": "Compile a regular expression pattern, returning a Pattern object."
  },
  "199": {
    "name": "escape",
    "module": "jax.random.typing.stdlib_re",
    "fullName": "jax.random.typing.stdlib_re.escape",
    "signature": "(pattern)",
    "description": "Escape special characters in a string."
  },
  "200": {
    "name": "findall",
    "module": "jax.random.typing.stdlib_re",
    "fullName": "jax.random.typing.stdlib_re.findall",
    "signature": "(pattern, string, flags=0)",
    "description": "Return a list of all non-overlapping matches in the string."
  },
  "201": {
    "name": "finditer",
    "module": "jax.random.typing.stdlib_re",
    "fullName": "jax.random.typing.stdlib_re.finditer",
    "signature": "(pattern, string, flags=0)",
    "description": "Return an iterator over all non-overlapping matches in the"
  },
  "202": {
    "name": "fullmatch",
    "module": "jax.random.typing.stdlib_re",
    "fullName": "jax.random.typing.stdlib_re.fullmatch",
    "signature": "(pattern, string, flags=0)",
    "description": "Try to apply the pattern to all of the string, returning"
  },
  "203": {
    "name": "match",
    "module": "jax.random.typing.stdlib_re",
    "fullName": "jax.random.typing.stdlib_re.match",
    "signature": "(pattern, string, flags=0)",
    "description": "Try to apply the pattern at the start of the string, returning"
  },
  "204": {
    "name": "purge",
    "module": "jax.random.typing.stdlib_re",
    "fullName": "jax.random.typing.stdlib_re.purge",
    "signature": "()",
    "description": "Clear the regular expression caches"
  },
  "205": {
    "name": "search",
    "module": "jax.random.typing.stdlib_re",
    "fullName": "jax.random.typing.stdlib_re.search",
    "signature": "(pattern, string, flags=0)",
    "description": "Scan through string looking for a match to the pattern, returning"
  },
  "206": {
    "name": "split",
    "module": "jax.random.typing.stdlib_re",
    "fullName": "jax.random.typing.stdlib_re.split",
    "signature": "(pattern, string, maxsplit=0, flags=0)",
    "description": "Split the source string by the occurrences of the pattern,"
  },
  "207": {
    "name": "sub",
    "module": "jax.random.typing.stdlib_re",
    "fullName": "jax.random.typing.stdlib_re.sub",
    "signature": "(pattern, repl, string, count=0, flags=0)",
    "description": "Return the string obtained by replacing the leftmost"
  },
  "208": {
    "name": "subn",
    "module": "jax.random.typing.stdlib_re",
    "fullName": "jax.random.typing.stdlib_re.subn",
    "signature": "(pattern, repl, string, count=0, flags=0)",
    "description": "Return a 2-tuple containing (new_string, number)."
  },
  "209": {
    "name": "template",
    "module": "jax.random.typing.stdlib_re",
    "fullName": "jax.random.typing.stdlib_re.template",
    "signature": "(pattern, flags=0)",
    "description": "Compile a template pattern, returning a Pattern object"
  },
  "210": {
    "name": "expand_template",
    "module": "jax.random.typing.stdlib_re.sre_parse",
    "fullName": "jax.random.typing.stdlib_re.sre_parse.expand_template",
    "signature": "(template, match)",
    "description": "No description available."
  },
  "211": {
    "name": "fix_flags",
    "module": "jax.random.typing.stdlib_re.sre_parse",
    "fullName": "jax.random.typing.stdlib_re.sre_parse.fix_flags",
    "signature": "(src, flags)",
    "description": "No description available."
  },
  "212": {
    "name": "parse",
    "module": "jax.random.typing.stdlib_re.sre_parse",
    "fullName": "jax.random.typing.stdlib_re.sre_parse.parse",
    "signature": "(str, flags=0, state=None)",
    "description": "No description available."
  },
  "213": {
    "name": "parse_template",
    "module": "jax.random.typing.stdlib_re.sre_parse",
    "fullName": "jax.random.typing.stdlib_re.sre_parse.parse_template",
    "signature": "(source, state)",
    "description": "No description available."
  },
  "214": {
    "name": "compile",
    "module": "jax.random.typing.stdlib_re.sre_compile",
    "fullName": "jax.random.typing.stdlib_re.sre_compile.compile",
    "signature": "(p, flags=0)",
    "description": "No description available."
  },
  "215": {
    "name": "dis",
    "module": "jax.random.typing.stdlib_re.sre_compile",
    "fullName": "jax.random.typing.stdlib_re.sre_compile.dis",
    "signature": "(code)",
    "description": "No description available."
  },
  "216": {
    "name": "isstring",
    "module": "jax.random.typing.stdlib_re.sre_compile",
    "fullName": "jax.random.typing.stdlib_re.sre_compile.isstring",
    "signature": "(obj)",
    "description": "No description available."
  },
  "217": {
    "name": "cache",
    "module": "jax.random.typing.stdlib_re.functools",
    "fullName": "jax.random.typing.stdlib_re.functools.cache",
    "signature": "(user_function, /)",
    "description": "Simple lightweight unbounded cache.  Sometimes called \"memoize\"."
  },
  "218": {
    "name": "lru_cache",
    "module": "jax.random.typing.stdlib_re.functools",
    "fullName": "jax.random.typing.stdlib_re.functools.lru_cache",
    "signature": "(maxsize=128, typed=False)",
    "description": "Least-recently-used cache decorator."
  },
  "219": {
    "name": "namedtuple",
    "module": "jax.random.typing.stdlib_re.functools",
    "fullName": "jax.random.typing.stdlib_re.functools.namedtuple",
    "signature": "(typename, field_names, *, rename=False, defaults=None, module=None)",
    "description": "Returns a new subclass of tuple with named fields."
  },
  "220": {
    "name": "recursive_repr",
    "module": "jax.random.typing.stdlib_re.functools",
    "fullName": "jax.random.typing.stdlib_re.functools.recursive_repr",
    "signature": "(fillvalue='...')",
    "description": "Decorator to make a repr function return fillvalue for a recursive call"
  },
  "221": {
    "name": "singledispatch",
    "module": "jax.random.typing.stdlib_re.functools",
    "fullName": "jax.random.typing.stdlib_re.functools.singledispatch",
    "signature": "(func)",
    "description": "Single-dispatch generic function decorator."
  },
  "222": {
    "name": "total_ordering",
    "module": "jax.random.typing.stdlib_re.functools",
    "fullName": "jax.random.typing.stdlib_re.functools.total_ordering",
    "signature": "(cls)",
    "description": "Class decorator that fills in missing ordering methods"
  },
  "223": {
    "name": "update_wrapper",
    "module": "jax.random.typing.stdlib_re.functools",
    "fullName": "jax.random.typing.stdlib_re.functools.update_wrapper",
    "signature": "(wrapper, wrapped, assigned=('__module__', '__name__', '__qualname__', '__doc__', '__annotations__'), updated=('__dict__',))",
    "description": "Update a wrapper function to look like the wrapped function"
  },
  "224": {
    "name": "wraps",
    "module": "jax.random.typing.stdlib_re.functools",
    "fullName": "jax.random.typing.stdlib_re.functools.wraps",
    "signature": "(wrapped, assigned=('__module__', '__name__', '__qualname__', '__doc__', '__annotations__'), updated=('__dict__',))",
    "description": "Decorator factory to apply update_wrapper() to a wrapper function"
  },
  "225": {
    "name": "unique",
    "module": "jax.random.typing.stdlib_re.enum",
    "fullName": "jax.random.typing.stdlib_re.enum.unique",
    "signature": "(enumeration)",
    "description": "Class decorator for enumerations ensuring unique member values."
  },
  "226": {
    "name": "add_extension",
    "module": "jax.random.typing.stdlib_re.copyreg",
    "fullName": "jax.random.typing.stdlib_re.copyreg.add_extension",
    "signature": "(module, name, code)",
    "description": "Register an extension code."
  },
  "227": {
    "name": "clear_extension_cache",
    "module": "jax.random.typing.stdlib_re.copyreg",
    "fullName": "jax.random.typing.stdlib_re.copyreg.clear_extension_cache",
    "signature": "()",
    "description": "No description available."
  },
  "228": {
    "name": "constructor",
    "module": "jax.random.typing.stdlib_re.copyreg",
    "fullName": "jax.random.typing.stdlib_re.copyreg.constructor",
    "signature": "(object)",
    "description": "No description available."
  },
  "229": {
    "name": "pickle",
    "module": "jax.random.typing.stdlib_re.copyreg",
    "fullName": "jax.random.typing.stdlib_re.copyreg.pickle",
    "signature": "(ob_type, pickle_function, constructor_ob=None)",
    "description": "No description available."
  },
  "230": {
    "name": "pickle_complex",
    "module": "jax.random.typing.stdlib_re.copyreg",
    "fullName": "jax.random.typing.stdlib_re.copyreg.pickle_complex",
    "signature": "(c)",
    "description": "No description available."
  },
  "231": {
    "name": "remove_extension",
    "module": "jax.random.typing.stdlib_re.copyreg",
    "fullName": "jax.random.typing.stdlib_re.copyreg.remove_extension",
    "signature": "(module, name, code)",
    "description": "Unregister an extension code.  For testing only."
  },
  "232": {
    "name": "asynccontextmanager",
    "module": "jax.random.typing.contextlib",
    "fullName": "jax.random.typing.contextlib.asynccontextmanager",
    "signature": "(func)",
    "description": "@asynccontextmanager decorator."
  },
  "233": {
    "name": "contextmanager",
    "module": "jax.random.typing.contextlib",
    "fullName": "jax.random.typing.contextlib.contextmanager",
    "signature": "(func)",
    "description": "@contextmanager decorator."
  },
  "234": {
    "name": "wraps",
    "module": "jax.random.typing.contextlib",
    "fullName": "jax.random.typing.contextlib.wraps",
    "signature": "(wrapped, assigned=('__module__', '__name__', '__qualname__', '__doc__', '__annotations__'), updated=('__dict__',))",
    "description": "Decorator factory to apply update_wrapper() to a wrapper function"
  },
  "235": {
    "name": "abstractmethod",
    "module": "jax.random.typing.contextlib.abc",
    "fullName": "jax.random.typing.contextlib.abc.abstractmethod",
    "signature": "(funcobj)",
    "description": "A decorator indicating abstract methods."
  },
  "236": {
    "name": "namedtuple",
    "module": "jax.random.typing.collections",
    "fullName": "jax.random.typing.collections.namedtuple",
    "signature": "(typename, field_names, *, rename=False, defaults=None, module=None)",
    "description": "Returns a new subclass of tuple with named fields."
  },
  "237": {
    "name": "annotate_function",
    "module": "jax.profiler",
    "fullName": "jax.profiler.annotate_function",
    "signature": "(func: Callable, name: Optional[str] = None, **decorator_kwargs)",
    "description": "Decorator that generates a trace event for the execution of a function."
  },
  "238": {
    "name": "device_memory_profile",
    "module": "jax.profiler",
    "fullName": "jax.profiler.device_memory_profile",
    "signature": "(backend: Optional[str] = None) -> bytes",
    "description": "Captures a JAX device memory profile as ``pprof``-format protocol buffer."
  },
  "239": {
    "name": "save_device_memory_profile",
    "module": "jax.profiler",
    "fullName": "jax.profiler.save_device_memory_profile",
    "signature": "(filename, backend: Optional[str] = None) -> None",
    "description": "Collects a device memory profile and writes it to a file."
  },
  "240": {
    "name": "start_server",
    "module": "jax.profiler",
    "fullName": "jax.profiler.start_server",
    "signature": "(port: int) -> jaxlib.xla_extension.profiler.ProfilerServer",
    "description": "Starts the profiler server on port `port`."
  },
  "241": {
    "name": "start_trace",
    "module": "jax.profiler",
    "fullName": "jax.profiler.start_trace",
    "signature": "(log_dir, create_perfetto_link: bool = False, create_perfetto_trace: bool = False) -> None",
    "description": "Starts a profiler trace."
  },
  "242": {
    "name": "stop_server",
    "module": "jax.profiler",
    "fullName": "jax.profiler.stop_server",
    "signature": "()",
    "description": "Stops the running profiler server."
  },
  "243": {
    "name": "stop_trace",
    "module": "jax.profiler",
    "fullName": "jax.profiler.stop_trace",
    "signature": "()",
    "description": "Stops the currently-running profiler trace."
  },
  "244": {
    "name": "trace",
    "module": "jax.profiler",
    "fullName": "jax.profiler.trace",
    "signature": "(log_dir, create_perfetto_link=False, create_perfetto_trace=False)",
    "description": "Context manager to take a profiler trace."
  },
  "245": {
    "name": "segment_max",
    "module": "jax.ops",
    "fullName": "jax.ops.segment_max",
    "signature": "(data: Any, segment_ids: Any, num_segments: Optional[int] = None, indices_are_sorted: bool = False, unique_indices: bool = False, bucket_size: Optional[int] = None, mode: Optional[jax._src.lax.slicing.GatherScatterMode] = None) -> Any",
    "description": "Computes the maximum within segments of an array."
  },
  "246": {
    "name": "segment_min",
    "module": "jax.ops",
    "fullName": "jax.ops.segment_min",
    "signature": "(data: Any, segment_ids: Any, num_segments: Optional[int] = None, indices_are_sorted: bool = False, unique_indices: bool = False, bucket_size: Optional[int] = None, mode: Optional[jax._src.lax.slicing.GatherScatterMode] = None) -> Any",
    "description": "Computes the minimum within segments of an array."
  },
  "247": {
    "name": "segment_prod",
    "module": "jax.ops",
    "fullName": "jax.ops.segment_prod",
    "signature": "(data: Any, segment_ids: Any, num_segments: Optional[int] = None, indices_are_sorted: bool = False, unique_indices: bool = False, bucket_size: Optional[int] = None, mode: Optional[jax._src.lax.slicing.GatherScatterMode] = None) -> Any",
    "description": "Computes the product within segments of an array."
  },
  "248": {
    "name": "segment_sum",
    "module": "jax.ops",
    "fullName": "jax.ops.segment_sum",
    "signature": "(data: Any, segment_ids: Any, num_segments: Optional[int] = None, indices_are_sorted: bool = False, unique_indices: bool = False, bucket_size: Optional[int] = None, mode: Optional[jax._src.lax.slicing.GatherScatterMode] = None) -> Any",
    "description": "Computes the sum within segments of an array."
  },
  "249": {
    "name": "abs",
    "module": "jax.numpy",
    "fullName": "jax.numpy.abs",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], /) -> jax.Array",
    "description": "Calculate the absolute value element-wise."
  },
  "250": {
    "name": "absolute",
    "module": "jax.numpy",
    "fullName": "jax.numpy.absolute",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], /) -> jax.Array",
    "description": "Calculate the absolute value element-wise."
  },
  "251": {
    "name": "add",
    "module": "jax.numpy",
    "fullName": "jax.numpy.add",
    "signature": "(x1, x2, /)",
    "description": "Add arguments element-wise."
  },
  "252": {
    "name": "all",
    "module": "jax.numpy",
    "fullName": "jax.numpy.all",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], axis: Union[NoneType, int, Sequence[int]] = None, out: None = None, keepdims: bool = False, *, where: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, NoneType] = None) -> jax.Array",
    "description": "Test whether all array elements along a given axis evaluate to True."
  },
  "253": {
    "name": "allclose",
    "module": "jax.numpy",
    "fullName": "jax.numpy.allclose",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], b: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], rtol: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex] = 1e-05, atol: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex] = 1e-08, equal_nan: bool = False) -> jax.Array",
    "description": "Returns True if two arrays are element-wise equal within a tolerance."
  },
  "254": {
    "name": "amax",
    "module": "jax.numpy",
    "fullName": "jax.numpy.amax",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], axis: Union[NoneType, int, Sequence[int]] = None, out: None = None, keepdims: bool = False, initial: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, NoneType] = None, where: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, NoneType] = None) -> jax.Array",
    "description": "Return the maximum of an array or maximum along an axis."
  },
  "255": {
    "name": "amin",
    "module": "jax.numpy",
    "fullName": "jax.numpy.amin",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], axis: Union[NoneType, int, Sequence[int]] = None, out: None = None, keepdims: bool = False, initial: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, NoneType] = None, where: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, NoneType] = None) -> jax.Array",
    "description": "Return the minimum of an array or minimum along an axis."
  },
  "256": {
    "name": "angle",
    "module": "jax.numpy",
    "fullName": "jax.numpy.angle",
    "signature": "(z: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], deg: bool = False) -> jax.Array",
    "description": "Return the angle of the complex argument."
  },
  "257": {
    "name": "any",
    "module": "jax.numpy",
    "fullName": "jax.numpy.any",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], axis: Union[NoneType, int, Sequence[int]] = None, out: None = None, keepdims: bool = False, *, where: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, NoneType] = None) -> jax.Array",
    "description": "Test whether any array element along a given axis evaluates to True."
  },
  "258": {
    "name": "append",
    "module": "jax.numpy",
    "fullName": "jax.numpy.append",
    "signature": "(arr, values, axis: Optional[int] = None)",
    "description": "Append values to the end of an array."
  },
  "259": {
    "name": "apply_along_axis",
    "module": "jax.numpy",
    "fullName": "jax.numpy.apply_along_axis",
    "signature": "(func1d, axis: int, arr, *args, **kwargs)",
    "description": "Apply a function to 1-D slices along the given axis."
  },
  "260": {
    "name": "apply_over_axes",
    "module": "jax.numpy",
    "fullName": "jax.numpy.apply_over_axes",
    "signature": "(func, a, axes)",
    "description": "Apply a function repeatedly over multiple axes."
  },
  "261": {
    "name": "arange",
    "module": "jax.numpy",
    "fullName": "jax.numpy.arange",
    "signature": "(start: Union[int, Any], stop: Union[int, Any, NoneType] = None, step: Union[int, Any, NoneType] = None, dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType, NoneType] = None) -> jax.Array",
    "description": "Return evenly spaced values within a given interval."
  },
  "262": {
    "name": "arccos",
    "module": "jax.numpy",
    "fullName": "jax.numpy.arccos",
    "signature": "(x, /)",
    "description": "Trigonometric inverse cosine, element-wise."
  },
  "263": {
    "name": "arccosh",
    "module": "jax.numpy",
    "fullName": "jax.numpy.arccosh",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], /) -> jax.Array",
    "description": "Inverse hyperbolic cosine, element-wise."
  },
  "264": {
    "name": "arcsin",
    "module": "jax.numpy",
    "fullName": "jax.numpy.arcsin",
    "signature": "(x, /)",
    "description": "Inverse sine, element-wise."
  },
  "265": {
    "name": "arcsinh",
    "module": "jax.numpy",
    "fullName": "jax.numpy.arcsinh",
    "signature": "(x, /)",
    "description": "Inverse hyperbolic sine element-wise."
  },
  "266": {
    "name": "arctan",
    "module": "jax.numpy",
    "fullName": "jax.numpy.arctan",
    "signature": "(x, /)",
    "description": "Trigonometric inverse tangent, element-wise."
  },
  "267": {
    "name": "arctan2",
    "module": "jax.numpy",
    "fullName": "jax.numpy.arctan2",
    "signature": "(x1, x2, /)",
    "description": "Element-wise arc tangent of ``x1/x2`` choosing the quadrant correctly."
  },
  "268": {
    "name": "arctanh",
    "module": "jax.numpy",
    "fullName": "jax.numpy.arctanh",
    "signature": "(x, /)",
    "description": "Inverse hyperbolic tangent element-wise."
  },
  "269": {
    "name": "argmax",
    "module": "jax.numpy",
    "fullName": "jax.numpy.argmax",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], axis: Optional[int] = None, out=None, keepdims=None) -> jax.Array",
    "description": "Returns the indices of the maximum values along an axis."
  },
  "270": {
    "name": "argmin",
    "module": "jax.numpy",
    "fullName": "jax.numpy.argmin",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], axis: Optional[int] = None, out=None, keepdims=None) -> jax.Array",
    "description": "Returns the indices of the minimum values along an axis."
  },
  "271": {
    "name": "argpartition",
    "module": "jax.numpy",
    "fullName": "jax.numpy.argpartition",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], kth: int, axis: int = -1) -> jax.Array",
    "description": "Perform an indirect partition along the given axis using the"
  },
  "272": {
    "name": "argsort",
    "module": "jax.numpy",
    "fullName": "jax.numpy.argsort",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], axis: Optional[int] = -1, kind: str = 'stable', order=None) -> jax.Array",
    "description": "Returns the indices that would sort an array."
  },
  "273": {
    "name": "argwhere",
    "module": "jax.numpy",
    "fullName": "jax.numpy.argwhere",
    "signature": "(a, *, size=None, fill_value=None)",
    "description": "Find the indices of array elements that are non-zero, grouped by element."
  },
  "274": {
    "name": "around",
    "module": "jax.numpy",
    "fullName": "jax.numpy.around",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], decimals: int = 0, out: None = None) -> jax.Array",
    "description": "Round an array to the given number of decimals."
  },
  "275": {
    "name": "array",
    "module": "jax.numpy",
    "fullName": "jax.numpy.array",
    "signature": "(object: Any, dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType, NoneType] = None, copy: bool = True, order: Optional[str] = 'K', ndmin: int = 0) -> jax.Array",
    "description": "Create an array."
  },
  "276": {
    "name": "array_equal",
    "module": "jax.numpy",
    "fullName": "jax.numpy.array_equal",
    "signature": "(a1: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], a2: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], equal_nan: bool = False) -> jax.Array",
    "description": "True if two arrays have the same shape and elements, False otherwise."
  },
  "277": {
    "name": "array_equiv",
    "module": "jax.numpy",
    "fullName": "jax.numpy.array_equiv",
    "signature": "(a1: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], a2: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Returns True if input arrays are shape consistent and all elements equal."
  },
  "278": {
    "name": "array_split",
    "module": "jax.numpy",
    "fullName": "jax.numpy.array_split",
    "signature": "(ary: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], indices_or_sections: Union[int, Sequence[int], jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, float, complex], axis: int = 0) -> List[jax.Array]",
    "description": "Split an array into multiple sub-arrays."
  },
  "279": {
    "name": "asarray",
    "module": "jax.numpy",
    "fullName": "jax.numpy.asarray",
    "signature": "(a: Any, dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType, NoneType] = None, order: Optional[str] = None) -> jax.Array",
    "description": "Convert the input to an array."
  },
  "280": {
    "name": "atleast_1d",
    "module": "jax.numpy",
    "fullName": "jax.numpy.atleast_1d",
    "signature": "(*arys: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> Union[jax.Array, List[jax.Array]]",
    "description": "Convert inputs to arrays with at least one dimension."
  },
  "281": {
    "name": "atleast_2d",
    "module": "jax.numpy",
    "fullName": "jax.numpy.atleast_2d",
    "signature": "(*arys: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> Union[jax.Array, List[jax.Array]]",
    "description": "View inputs as arrays with at least two dimensions."
  },
  "282": {
    "name": "atleast_3d",
    "module": "jax.numpy",
    "fullName": "jax.numpy.atleast_3d",
    "signature": "(*arys: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> Union[jax.Array, List[jax.Array]]",
    "description": "View inputs as arrays with at least three dimensions."
  },
  "283": {
    "name": "average",
    "module": "jax.numpy",
    "fullName": "jax.numpy.average",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], axis: Union[NoneType, int, Sequence[int]] = None, weights: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, NoneType] = None, returned: bool = False, keepdims: bool = False) -> Union[jax.Array, Tuple[jax.Array, jax.Array]]",
    "description": "Compute the weighted average along the specified axis."
  },
  "284": {
    "name": "bartlett",
    "module": "jax.numpy",
    "fullName": "jax.numpy.bartlett",
    "signature": "(M: int) -> jax.Array",
    "description": "Return the Bartlett window."
  },
  "285": {
    "name": "bincount",
    "module": "jax.numpy",
    "fullName": "jax.numpy.bincount",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], weights: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, NoneType] = None, minlength: int = 0, *, length: Optional[int] = None) -> jax.Array",
    "description": "Count number of occurrences of each value in array of non-negative ints."
  },
  "286": {
    "name": "bitwise_and",
    "module": "jax.numpy",
    "fullName": "jax.numpy.bitwise_and",
    "signature": "(x1, x2, /)",
    "description": "Compute the bit-wise AND of two arrays element-wise."
  },
  "287": {
    "name": "bitwise_not",
    "module": "jax.numpy",
    "fullName": "jax.numpy.bitwise_not",
    "signature": "(x, /)",
    "description": "Compute bit-wise inversion, or bit-wise NOT, element-wise."
  },
  "288": {
    "name": "bitwise_or",
    "module": "jax.numpy",
    "fullName": "jax.numpy.bitwise_or",
    "signature": "(x1, x2, /)",
    "description": "Compute the bit-wise OR of two arrays element-wise."
  },
  "289": {
    "name": "bitwise_xor",
    "module": "jax.numpy",
    "fullName": "jax.numpy.bitwise_xor",
    "signature": "(x1, x2, /)",
    "description": "Compute the bit-wise XOR of two arrays element-wise."
  },
  "290": {
    "name": "blackman",
    "module": "jax.numpy",
    "fullName": "jax.numpy.blackman",
    "signature": "(M: int) -> jax.Array",
    "description": "Return the Blackman window."
  },
  "291": {
    "name": "block",
    "module": "jax.numpy",
    "fullName": "jax.numpy.block",
    "signature": "(arrays: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, List[Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]]]) -> jax.Array",
    "description": "Assemble an nd-array from nested lists of blocks."
  },
  "292": {
    "name": "broadcast_arrays",
    "module": "jax.numpy",
    "fullName": "jax.numpy.broadcast_arrays",
    "signature": "(*args: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> List[jax.Array]",
    "description": "Broadcast any number of arrays against each other."
  },
  "293": {
    "name": "broadcast_shapes",
    "module": "jax.numpy",
    "fullName": "jax.numpy.broadcast_shapes",
    "signature": "(*shapes)",
    "description": "Broadcast the input shapes into a single shape."
  },
  "294": {
    "name": "broadcast_to",
    "module": "jax.numpy",
    "fullName": "jax.numpy.broadcast_to",
    "signature": "(array: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], shape: Sequence[Union[int, Any]]) -> jax.Array",
    "description": "Broadcast an array to a new shape."
  },
  "295": {
    "name": "cbrt",
    "module": "jax.numpy",
    "fullName": "jax.numpy.cbrt",
    "signature": "(x, /)",
    "description": "Return the cube-root of an array, element-wise."
  },
  "296": {
    "name": "ceil",
    "module": "jax.numpy",
    "fullName": "jax.numpy.ceil",
    "signature": "(x, /)",
    "description": "Return the ceiling of the input, element-wise."
  },
  "297": {
    "name": "choose",
    "module": "jax.numpy",
    "fullName": "jax.numpy.choose",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], choices: Sequence[Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]], out: None = None, mode: str = 'raise') -> jax.Array",
    "description": "Construct an array from an index array and a list of arrays to choose from."
  },
  "298": {
    "name": "clip",
    "module": "jax.numpy",
    "fullName": "jax.numpy.clip",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], a_min: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, NoneType] = None, a_max: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, NoneType] = None, out: None = None) -> jax.Array",
    "description": "Clip (limit) the values in an array."
  },
  "299": {
    "name": "column_stack",
    "module": "jax.numpy",
    "fullName": "jax.numpy.column_stack",
    "signature": "(tup: Union[numpy.ndarray, jax.Array, Sequence[Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]]]) -> jax.Array",
    "description": "Stack 1-D arrays as columns into a 2-D array."
  },
  "300": {
    "name": "compress",
    "module": "jax.numpy",
    "fullName": "jax.numpy.compress",
    "signature": "(condition: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], axis: Optional[int] = None, out: None = None) -> jax.Array",
    "description": "Return selected slices of an array along given axis."
  },
  "301": {
    "name": "concatenate",
    "module": "jax.numpy",
    "fullName": "jax.numpy.concatenate",
    "signature": "(arrays: Union[numpy.ndarray, jax.Array, Sequence[Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]]], axis: Optional[int] = 0, dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType, NoneType] = None) -> jax.Array",
    "description": "Join a sequence of arrays along an existing axis."
  },
  "302": {
    "name": "conj",
    "module": "jax.numpy",
    "fullName": "jax.numpy.conj",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], /) -> jax.Array",
    "description": "Return the complex conjugate, element-wise."
  },
  "303": {
    "name": "conjugate",
    "module": "jax.numpy",
    "fullName": "jax.numpy.conjugate",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], /) -> jax.Array",
    "description": "Return the complex conjugate, element-wise."
  },
  "304": {
    "name": "convolve",
    "module": "jax.numpy",
    "fullName": "jax.numpy.convolve",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], v: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], mode: str = 'full', *, precision: Union[NoneType, str, jax._src.lax.lax.Precision, Tuple[str, str], Tuple[jax._src.lax.lax.Precision, jax._src.lax.lax.Precision]] = None) -> jax.Array",
    "description": "Returns the discrete, linear convolution of two one-dimensional sequences."
  },
  "305": {
    "name": "copy",
    "module": "jax.numpy",
    "fullName": "jax.numpy.copy",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], order: Optional[str] = None) -> jax.Array",
    "description": "Return an array copy of the given object."
  },
  "306": {
    "name": "copysign",
    "module": "jax.numpy",
    "fullName": "jax.numpy.copysign",
    "signature": "(x1: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], x2: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], /) -> jax.Array",
    "description": "Change the sign of x1 to that of x2, element-wise."
  },
  "307": {
    "name": "corrcoef",
    "module": "jax.numpy",
    "fullName": "jax.numpy.corrcoef",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], y: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, NoneType] = None, rowvar: bool = True) -> jax.Array",
    "description": "Return Pearson product-moment correlation coefficients."
  },
  "308": {
    "name": "correlate",
    "module": "jax.numpy",
    "fullName": "jax.numpy.correlate",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], v: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], mode: str = 'valid', *, precision: Union[NoneType, str, jax._src.lax.lax.Precision, Tuple[str, str], Tuple[jax._src.lax.lax.Precision, jax._src.lax.lax.Precision]] = None) -> jax.Array",
    "description": "Cross-correlation of two 1-dimensional sequences."
  },
  "309": {
    "name": "cos",
    "module": "jax.numpy",
    "fullName": "jax.numpy.cos",
    "signature": "(x, /)",
    "description": "Cosine element-wise."
  },
  "310": {
    "name": "cosh",
    "module": "jax.numpy",
    "fullName": "jax.numpy.cosh",
    "signature": "(x, /)",
    "description": "Hyperbolic cosine, element-wise."
  },
  "311": {
    "name": "count_nonzero",
    "module": "jax.numpy",
    "fullName": "jax.numpy.count_nonzero",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], axis: Union[NoneType, int, Sequence[int]] = None, keepdims: bool = False) -> jax.Array",
    "description": "Counts the number of non-zero values in the array ``a``."
  },
  "312": {
    "name": "cov",
    "module": "jax.numpy",
    "fullName": "jax.numpy.cov",
    "signature": "(m: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], y: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, NoneType] = None, rowvar: bool = True, bias: bool = False, ddof: Optional[int] = None, fweights: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, NoneType] = None, aweights: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, NoneType] = None) -> jax.Array",
    "description": "Estimate a covariance matrix, given data and weights."
  },
  "313": {
    "name": "cross",
    "module": "jax.numpy",
    "fullName": "jax.numpy.cross",
    "signature": "(a, b, axisa: int = -1, axisb: int = -1, axisc: int = -1, axis: Optional[int] = None)",
    "description": "Return the cross product of two (arrays of) vectors."
  },
  "314": {
    "name": "cumprod",
    "module": "jax.numpy",
    "fullName": "jax.numpy.cumprod",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], axis: Union[NoneType, int, Sequence[int]] = None, dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType] = None, out: None = None) -> jax.Array",
    "description": "Return the cumulative product of elements along a given axis."
  },
  "315": {
    "name": "cumsum",
    "module": "jax.numpy",
    "fullName": "jax.numpy.cumsum",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], axis: Union[NoneType, int, Sequence[int]] = None, dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType] = None, out: None = None) -> jax.Array",
    "description": "Return the cumulative sum of the elements along a given axis."
  },
  "316": {
    "name": "deg2rad",
    "module": "jax.numpy",
    "fullName": "jax.numpy.deg2rad",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], /) -> jax.Array",
    "description": "Convert angles from degrees to radians."
  },
  "317": {
    "name": "degrees",
    "module": "jax.numpy",
    "fullName": "jax.numpy.degrees",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], /) -> jax.Array",
    "description": "Convert angles from radians to degrees."
  },
  "318": {
    "name": "delete",
    "module": "jax.numpy",
    "fullName": "jax.numpy.delete",
    "signature": "(arr, obj, axis=None, *, assume_unique_indices=False)",
    "description": "Return a new array with sub-arrays along an axis deleted. For a one"
  },
  "319": {
    "name": "diag",
    "module": "jax.numpy",
    "fullName": "jax.numpy.diag",
    "signature": "(v, k=0)",
    "description": "Extract a diagonal or construct a diagonal array."
  },
  "320": {
    "name": "diag_indices",
    "module": "jax.numpy",
    "fullName": "jax.numpy.diag_indices",
    "signature": "(n, ndim=2)",
    "description": "Return the indices to access the main diagonal of an array."
  },
  "321": {
    "name": "diag_indices_from",
    "module": "jax.numpy",
    "fullName": "jax.numpy.diag_indices_from",
    "signature": "(arr)",
    "description": "Return the indices to access the main diagonal of an n-dimensional array."
  },
  "322": {
    "name": "diagflat",
    "module": "jax.numpy",
    "fullName": "jax.numpy.diagflat",
    "signature": "(v, k=0)",
    "description": "Create a two-dimensional array with the flattened input as a diagonal."
  },
  "323": {
    "name": "diagonal",
    "module": "jax.numpy",
    "fullName": "jax.numpy.diagonal",
    "signature": "(a, offset=0, axis1: int = 0, axis2: int = 1)",
    "description": "Return specified diagonals."
  },
  "324": {
    "name": "diff",
    "module": "jax.numpy",
    "fullName": "jax.numpy.diff",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], n: int = 1, axis: int = -1, prepend: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, NoneType] = None, append: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, NoneType] = None) -> jax.Array",
    "description": "Calculate the n-th discrete difference along the given axis."
  },
  "325": {
    "name": "digitize",
    "module": "jax.numpy",
    "fullName": "jax.numpy.digitize",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], bins: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], right: bool = False) -> jax.Array",
    "description": "Return the indices of the bins to which each value in input array belongs."
  },
  "326": {
    "name": "divide",
    "module": "jax.numpy",
    "fullName": "jax.numpy.divide",
    "signature": "(x1: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], x2: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], /) -> jax.Array",
    "description": "Divide arguments element-wise."
  },
  "327": {
    "name": "divmod",
    "module": "jax.numpy",
    "fullName": "jax.numpy.divmod",
    "signature": "(x1: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], x2: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], /) -> Tuple[jax.Array, jax.Array]",
    "description": "Return element-wise quotient and remainder simultaneously."
  },
  "328": {
    "name": "dot",
    "module": "jax.numpy",
    "fullName": "jax.numpy.dot",
    "signature": "(a, b, *, precision=None)",
    "description": "Dot product of two arrays. Specifically,"
  },
  "329": {
    "name": "dsplit",
    "module": "jax.numpy",
    "fullName": "jax.numpy.dsplit",
    "signature": "(ary: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], indices_or_sections: Union[int, Sequence[int], jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, float, complex]) -> List[jax.Array]",
    "description": "Split array into multiple sub-arrays along the 3rd axis (depth)."
  },
  "330": {
    "name": "dstack",
    "module": "jax.numpy",
    "fullName": "jax.numpy.dstack",
    "signature": "(tup: Union[numpy.ndarray, jax.Array, Sequence[Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]]], dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType, NoneType] = None) -> jax.Array",
    "description": "Stack arrays in sequence depth wise (along third axis)."
  },
  "331": {
    "name": "ediff1d",
    "module": "jax.numpy",
    "fullName": "jax.numpy.ediff1d",
    "signature": "(ary: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], to_end: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, NoneType] = None, to_begin: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, NoneType] = None) -> jax.Array",
    "description": "The differences between consecutive elements of an array."
  },
  "332": {
    "name": "einsum",
    "module": "jax.numpy",
    "fullName": "jax.numpy.einsum",
    "signature": "(subscripts, /, *operands, out: None = None, optimize: str = 'optimal', precision: Union[NoneType, str, jax._src.lax.lax.Precision, Tuple[str, str], Tuple[jax._src.lax.lax.Precision, jax._src.lax.lax.Precision]] = None, preferred_element_type: Union[Any, str, numpy.dtype, jax._src.SupportsDType, NoneType] = None, _use_xeinsum: bool = False, _dot_general: Callable[..., jax.Array] = <function dot_general at 0x00000267B34B6670>) -> jax.Array",
    "description": "Evaluates the Einstein summation convention on the operands."
  },
  "333": {
    "name": "einsum_path",
    "module": "jax.numpy",
    "fullName": "jax.numpy.einsum_path",
    "signature": "(subscripts, *operands, optimize='greedy')",
    "description": "Evaluates the lowest cost contraction order for an einsum expression by"
  },
  "334": {
    "name": "empty",
    "module": "jax.numpy",
    "fullName": "jax.numpy.empty",
    "signature": "(shape: Any, dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType, NoneType] = None) -> jax.Array",
    "description": "Return a new array of given shape and type, without initializing entries."
  },
  "335": {
    "name": "empty_like",
    "module": "jax.numpy",
    "fullName": "jax.numpy.empty_like",
    "signature": "(prototype: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, jax._src.DuckTypedArray], dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType, NoneType] = None, shape: Any = None) -> jax.Array",
    "description": "Return a new array with the same shape and type as a given array."
  },
  "336": {
    "name": "equal",
    "module": "jax.numpy",
    "fullName": "jax.numpy.equal",
    "signature": "(x1, x2, /)",
    "description": "Return (x1 == x2) element-wise."
  },
  "337": {
    "name": "exp",
    "module": "jax.numpy",
    "fullName": "jax.numpy.exp",
    "signature": "(x, /)",
    "description": "Calculate the exponential of all elements in the input array."
  },
  "338": {
    "name": "exp2",
    "module": "jax.numpy",
    "fullName": "jax.numpy.exp2",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], /) -> jax.Array",
    "description": "Calculate `2**p` for all `p` in the input array."
  },
  "339": {
    "name": "expand_dims",
    "module": "jax.numpy",
    "fullName": "jax.numpy.expand_dims",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], axis: Union[int, Sequence[int]]) -> jax.Array",
    "description": "Expand the shape of an array."
  },
  "340": {
    "name": "expm1",
    "module": "jax.numpy",
    "fullName": "jax.numpy.expm1",
    "signature": "(x, /)",
    "description": "Calculate ``exp(x) - 1`` for all elements in the array."
  },
  "341": {
    "name": "extract",
    "module": "jax.numpy",
    "fullName": "jax.numpy.extract",
    "signature": "(condition: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], arr: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Return the elements of an array that satisfy some condition."
  },
  "342": {
    "name": "eye",
    "module": "jax.numpy",
    "fullName": "jax.numpy.eye",
    "signature": "(N: Union[int, Any], M: Union[int, Any, NoneType] = None, k: int = 0, dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType, NoneType] = None) -> jax.Array",
    "description": "Return a 2-D array with ones on the diagonal and zeros elsewhere."
  },
  "343": {
    "name": "fabs",
    "module": "jax.numpy",
    "fullName": "jax.numpy.fabs",
    "signature": "(x, /)",
    "description": "Compute the absolute values element-wise."
  },
  "344": {
    "name": "fix",
    "module": "jax.numpy",
    "fullName": "jax.numpy.fix",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], out: None = None) -> jax.Array",
    "description": "Round to nearest integer towards zero."
  },
  "345": {
    "name": "flatnonzero",
    "module": "jax.numpy",
    "fullName": "jax.numpy.flatnonzero",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], *, size: Optional[int] = None, fill_value: Union[NoneType, jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, Tuple[Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]]] = None) -> jax.Array",
    "description": "Return indices that are non-zero in the flattened version of a."
  },
  "346": {
    "name": "flip",
    "module": "jax.numpy",
    "fullName": "jax.numpy.flip",
    "signature": "(m: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], axis: Union[int, Tuple[int, ...], NoneType] = None) -> jax.Array",
    "description": "Reverse the order of elements in an array along the given axis."
  },
  "347": {
    "name": "fliplr",
    "module": "jax.numpy",
    "fullName": "jax.numpy.fliplr",
    "signature": "(m: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Reverse the order of elements along axis 1 (left/right)."
  },
  "348": {
    "name": "flipud",
    "module": "jax.numpy",
    "fullName": "jax.numpy.flipud",
    "signature": "(m: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Reverse the order of elements along axis 0 (up/down)."
  },
  "349": {
    "name": "float_power",
    "module": "jax.numpy",
    "fullName": "jax.numpy.float_power",
    "signature": "(x1, x2, /)",
    "description": "First array elements raised to powers from second array, element-wise."
  },
  "350": {
    "name": "floor",
    "module": "jax.numpy",
    "fullName": "jax.numpy.floor",
    "signature": "(x, /)",
    "description": "Return the floor of the input, element-wise."
  },
  "351": {
    "name": "floor_divide",
    "module": "jax.numpy",
    "fullName": "jax.numpy.floor_divide",
    "signature": "(x1: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], x2: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], /) -> jax.Array",
    "description": "Return the largest integer smaller or equal to the division of the inputs."
  },
  "352": {
    "name": "fmax",
    "module": "jax.numpy",
    "fullName": "jax.numpy.fmax",
    "signature": "(x1: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], x2: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Element-wise maximum of array elements."
  },
  "353": {
    "name": "fmin",
    "module": "jax.numpy",
    "fullName": "jax.numpy.fmin",
    "signature": "(x1: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], x2: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Element-wise minimum of array elements."
  },
  "354": {
    "name": "fmod",
    "module": "jax.numpy",
    "fullName": "jax.numpy.fmod",
    "signature": "(x1: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], x2: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], /) -> jax.Array",
    "description": "Returns the element-wise remainder of division."
  },
  "355": {
    "name": "frexp",
    "module": "jax.numpy",
    "fullName": "jax.numpy.frexp",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], /) -> Tuple[jax.Array, jax.Array]",
    "description": "Decompose the elements of x into mantissa and twos exponent."
  },
  "356": {
    "name": "from_dlpack",
    "module": "jax.numpy",
    "fullName": "jax.numpy.from_dlpack",
    "signature": "(x: Any) -> jax.Array",
    "description": "Create a NumPy array from an object implementing the ``__dlpack__``"
  },
  "357": {
    "name": "frombuffer",
    "module": "jax.numpy",
    "fullName": "jax.numpy.frombuffer",
    "signature": "(buffer: Union[bytes, Any], dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType] = <class 'float'>, count: int = -1, offset: int = 0) -> jax.Array",
    "description": "Interpret a buffer as a 1-dimensional array."
  },
  "358": {
    "name": "fromfile",
    "module": "jax.numpy",
    "fullName": "jax.numpy.fromfile",
    "signature": "(*args, **kwargs)",
    "description": "Unimplemented JAX wrapper for jnp.fromfile."
  },
  "359": {
    "name": "fromfunction",
    "module": "jax.numpy",
    "fullName": "jax.numpy.fromfunction",
    "signature": "(function: Callable[..., jax.Array], shape: Any, *, dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType] = <class 'float'>, **kwargs) -> jax.Array",
    "description": "Construct an array by executing a function over each coordinate."
  },
  "360": {
    "name": "fromiter",
    "module": "jax.numpy",
    "fullName": "jax.numpy.fromiter",
    "signature": "(*args, **kwargs)",
    "description": "Unimplemented JAX wrapper for jnp.fromiter."
  },
  "361": {
    "name": "fromstring",
    "module": "jax.numpy",
    "fullName": "jax.numpy.fromstring",
    "signature": "(string: str, dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType] = <class 'float'>, count: int = -1, *, sep: str) -> jax.Array",
    "description": "A new 1-D array initialized from text data in a string."
  },
  "362": {
    "name": "full",
    "module": "jax.numpy",
    "fullName": "jax.numpy.full",
    "signature": "(shape: Any, fill_value: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType, NoneType] = None) -> jax.Array",
    "description": "Return a new array of given shape and type, filled with `fill_value`."
  },
  "363": {
    "name": "full_like",
    "module": "jax.numpy",
    "fullName": "jax.numpy.full_like",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, jax._src.DuckTypedArray], fill_value: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType, NoneType] = None, shape: Any = None) -> jax.Array",
    "description": "Return a full array with the same shape and type as a given array."
  },
  "364": {
    "name": "gcd",
    "module": "jax.numpy",
    "fullName": "jax.numpy.gcd",
    "signature": "(x1: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], x2: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Returns the greatest common divisor of ``|x1|`` and ``|x2|``"
  },
  "365": {
    "name": "geomspace",
    "module": "jax.numpy",
    "fullName": "jax.numpy.geomspace",
    "signature": "(start: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], stop: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], num: int = 50, endpoint: bool = True, dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType, NoneType] = None, axis: int = 0) -> jax.Array",
    "description": "Return numbers spaced evenly on a log scale (a geometric progression)."
  },
  "366": {
    "name": "get_printoptions",
    "module": "jax.numpy",
    "fullName": "jax.numpy.get_printoptions",
    "signature": "()",
    "description": "Return the current print options."
  },
  "367": {
    "name": "gradient",
    "module": "jax.numpy",
    "fullName": "jax.numpy.gradient",
    "signature": "(f: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], *varargs: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], axis: Union[int, Tuple[int, ...], NoneType] = None, edge_order: Optional[int] = None) -> Union[jax.Array, List[jax.Array]]",
    "description": "Return the gradient of an N-dimensional array."
  },
  "368": {
    "name": "greater",
    "module": "jax.numpy",
    "fullName": "jax.numpy.greater",
    "signature": "(x1, x2, /)",
    "description": "Return the truth value of (x1 > x2) element-wise."
  },
  "369": {
    "name": "greater_equal",
    "module": "jax.numpy",
    "fullName": "jax.numpy.greater_equal",
    "signature": "(x1, x2, /)",
    "description": "Return the truth value of (x1 >= x2) element-wise."
  },
  "370": {
    "name": "hamming",
    "module": "jax.numpy",
    "fullName": "jax.numpy.hamming",
    "signature": "(M: int) -> jax.Array",
    "description": "Return the Hamming window."
  },
  "371": {
    "name": "hanning",
    "module": "jax.numpy",
    "fullName": "jax.numpy.hanning",
    "signature": "(M: int) -> jax.Array",
    "description": "Return the Hanning window."
  },
  "372": {
    "name": "heaviside",
    "module": "jax.numpy",
    "fullName": "jax.numpy.heaviside",
    "signature": "(x1: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], x2: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], /) -> jax.Array",
    "description": "Compute the Heaviside step function."
  },
  "373": {
    "name": "histogram",
    "module": "jax.numpy",
    "fullName": "jax.numpy.histogram",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], bins: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex] = 10, range: Optional[Sequence[Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]]] = None, weights: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, NoneType] = None, density: Optional[bool] = None) -> Tuple[jax.Array, jax.Array]",
    "description": "Compute the histogram of a dataset."
  },
  "374": {
    "name": "histogram2d",
    "module": "jax.numpy",
    "fullName": "jax.numpy.histogram2d",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], y: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], bins: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, List[Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]]] = 10, range: Optional[Sequence[Union[NoneType, jax.Array, Sequence[Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]]]]] = None, weights: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, NoneType] = None, density: Optional[bool] = None) -> Tuple[jax.Array, jax.Array, jax.Array]",
    "description": "Compute the bi-dimensional histogram of two data samples."
  },
  "375": {
    "name": "histogram_bin_edges",
    "module": "jax.numpy",
    "fullName": "jax.numpy.histogram_bin_edges",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], bins: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex] = 10, range: Union[NoneType, jax.Array, Sequence[Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]]] = None, weights: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, NoneType] = None) -> jax.Array",
    "description": "Function to calculate only the edges of the bins used by the `histogram`"
  },
  "376": {
    "name": "histogramdd",
    "module": "jax.numpy",
    "fullName": "jax.numpy.histogramdd",
    "signature": "(sample: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], bins: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, List[Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]]] = 10, range: Optional[Sequence[Union[NoneType, jax.Array, Sequence[Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]]]]] = None, weights: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, NoneType] = None, density: Optional[bool] = None) -> Tuple[jax.Array, List[jax.Array]]",
    "description": "Compute the multidimensional histogram of some data."
  },
  "377": {
    "name": "hsplit",
    "module": "jax.numpy",
    "fullName": "jax.numpy.hsplit",
    "signature": "(ary: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], indices_or_sections: Union[int, Sequence[int], jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, float, complex]) -> List[jax.Array]",
    "description": "Split an array into multiple sub-arrays horizontally (column-wise)."
  },
  "378": {
    "name": "hstack",
    "module": "jax.numpy",
    "fullName": "jax.numpy.hstack",
    "signature": "(tup: Union[numpy.ndarray, jax.Array, Sequence[Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]]], dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType, NoneType] = None) -> jax.Array",
    "description": "Stack arrays in sequence horizontally (column wise)."
  },
  "379": {
    "name": "hypot",
    "module": "jax.numpy",
    "fullName": "jax.numpy.hypot",
    "signature": "(x1: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], x2: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], /) -> jax.Array",
    "description": "Given the \"legs\" of a right triangle, return its hypotenuse."
  },
  "380": {
    "name": "i0",
    "module": "jax.numpy",
    "fullName": "jax.numpy.i0",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Modified Bessel function of the first kind, order 0."
  },
  "381": {
    "name": "identity",
    "module": "jax.numpy",
    "fullName": "jax.numpy.identity",
    "signature": "(n: Union[int, Any], dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType, NoneType] = None) -> jax.Array",
    "description": "Return the identity array."
  },
  "382": {
    "name": "imag",
    "module": "jax.numpy",
    "fullName": "jax.numpy.imag",
    "signature": "(val: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], /) -> jax.Array",
    "description": "Return the imaginary part of the complex argument."
  },
  "383": {
    "name": "in1d",
    "module": "jax.numpy",
    "fullName": "jax.numpy.in1d",
    "signature": "(ar1: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], ar2: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], assume_unique: bool = False, invert: bool = False) -> jax.Array",
    "description": "Test whether each element of a 1-D array is also present in a second array."
  },
  "384": {
    "name": "indices",
    "module": "jax.numpy",
    "fullName": "jax.numpy.indices",
    "signature": "(dimensions: Sequence[int], dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType] = <class 'jax.numpy.int32'>, sparse: bool = False) -> Union[jax.Array, Tuple[jax.Array, ...]]",
    "description": "Return an array representing the indices of a grid."
  },
  "385": {
    "name": "inner",
    "module": "jax.numpy",
    "fullName": "jax.numpy.inner",
    "signature": "(a, b, *, precision=None)",
    "description": "Inner product of two arrays."
  },
  "386": {
    "name": "insert",
    "module": "jax.numpy",
    "fullName": "jax.numpy.insert",
    "signature": "(arr, obj, values, axis=None)",
    "description": "Insert values along the given axis before the given indices."
  },
  "387": {
    "name": "interp",
    "module": "jax.numpy",
    "fullName": "jax.numpy.interp",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], xp: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], fp: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], left: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, str, NoneType] = None, right: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, str, NoneType] = None, period: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, NoneType] = None) -> jax.Array",
    "description": "One-dimensional linear interpolation for monotonically increasing sample points."
  },
  "388": {
    "name": "intersect1d",
    "module": "jax.numpy",
    "fullName": "jax.numpy.intersect1d",
    "signature": "(ar1: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], ar2: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], assume_unique: bool = False, return_indices: bool = False) -> Union[jax.Array, Tuple[jax.Array, jax.Array, jax.Array]]",
    "description": "Find the intersection of two arrays."
  },
  "389": {
    "name": "invert",
    "module": "jax.numpy",
    "fullName": "jax.numpy.invert",
    "signature": "(x, /)",
    "description": "Compute bit-wise inversion, or bit-wise NOT, element-wise."
  },
  "390": {
    "name": "isclose",
    "module": "jax.numpy",
    "fullName": "jax.numpy.isclose",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], b: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], rtol: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex] = 1e-05, atol: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex] = 1e-08, equal_nan: bool = False) -> jax.Array",
    "description": "Returns a boolean array where two arrays are element-wise equal within a"
  },
  "391": {
    "name": "iscomplex",
    "module": "jax.numpy",
    "fullName": "jax.numpy.iscomplex",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Returns a bool array, where True if input element is complex."
  },
  "392": {
    "name": "iscomplexobj",
    "module": "jax.numpy",
    "fullName": "jax.numpy.iscomplexobj",
    "signature": "(x: Any) -> bool",
    "description": "Check for a complex type or an array of complex numbers."
  },
  "393": {
    "name": "isfinite",
    "module": "jax.numpy",
    "fullName": "jax.numpy.isfinite",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], /) -> jax.Array",
    "description": "Test element-wise for finiteness (not infinity and not Not a Number)."
  },
  "394": {
    "name": "isin",
    "module": "jax.numpy",
    "fullName": "jax.numpy.isin",
    "signature": "(element: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], test_elements: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], assume_unique: bool = False, invert: bool = False) -> jax.Array",
    "description": "Calculates ``element in test_elements``, broadcasting over `element` only."
  },
  "395": {
    "name": "isinf",
    "module": "jax.numpy",
    "fullName": "jax.numpy.isinf",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], /) -> jax.Array",
    "description": "Test element-wise for positive or negative infinity."
  },
  "396": {
    "name": "isnan",
    "module": "jax.numpy",
    "fullName": "jax.numpy.isnan",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], /) -> jax.Array",
    "description": "Test element-wise for NaN and return result as a boolean array."
  },
  "397": {
    "name": "isneginf",
    "module": "jax.numpy",
    "fullName": "jax.numpy.isneginf",
    "signature": "(x, /, out=None)",
    "description": "Test element-wise for negative infinity, return result as bool array."
  },
  "398": {
    "name": "isposinf",
    "module": "jax.numpy",
    "fullName": "jax.numpy.isposinf",
    "signature": "(x, /, out=None)",
    "description": "Test element-wise for positive infinity, return result as bool array."
  },
  "399": {
    "name": "isreal",
    "module": "jax.numpy",
    "fullName": "jax.numpy.isreal",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Returns a bool array, where True if input element is real."
  },
  "400": {
    "name": "isrealobj",
    "module": "jax.numpy",
    "fullName": "jax.numpy.isrealobj",
    "signature": "(x: Any) -> bool",
    "description": "Return True if x is a not complex type or an array of complex numbers."
  },
  "401": {
    "name": "isscalar",
    "module": "jax.numpy",
    "fullName": "jax.numpy.isscalar",
    "signature": "(element: Any) -> bool",
    "description": "Returns True if the type of `element` is a scalar type."
  },
  "402": {
    "name": "issubdtype",
    "module": "jax.numpy",
    "fullName": "jax.numpy.issubdtype",
    "signature": "(arg1: Union[Any, str, numpy.dtype, jax._src.SupportsDType], arg2: Union[Any, str, numpy.dtype, jax._src.SupportsDType]) -> bool",
    "description": "Returns True if first argument is a typecode lower/equal in type hierarchy."
  },
  "403": {
    "name": "issubsctype",
    "module": "jax.numpy",
    "fullName": "jax.numpy.issubsctype",
    "signature": "(arg1, arg2)",
    "description": "Determine if the first argument is a subclass of the second argument."
  },
  "404": {
    "name": "iterable",
    "module": "jax.numpy",
    "fullName": "jax.numpy.iterable",
    "signature": "(y)",
    "description": "Check whether or not an object can be iterated over."
  },
  "405": {
    "name": "ix_",
    "module": "jax.numpy",
    "fullName": "jax.numpy.ix_",
    "signature": "(*args: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> Tuple[jax.Array, ...]",
    "description": "Construct an open mesh from multiple sequences."
  },
  "406": {
    "name": "kaiser",
    "module": "jax.numpy",
    "fullName": "jax.numpy.kaiser",
    "signature": "(M: int, beta: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Return the Kaiser window."
  },
  "407": {
    "name": "kron",
    "module": "jax.numpy",
    "fullName": "jax.numpy.kron",
    "signature": "(a, b)",
    "description": "Kronecker product of two arrays."
  },
  "408": {
    "name": "lcm",
    "module": "jax.numpy",
    "fullName": "jax.numpy.lcm",
    "signature": "(x1: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], x2: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Returns the lowest common multiple of ``|x1|`` and ``|x2|``"
  },
  "409": {
    "name": "ldexp",
    "module": "jax.numpy",
    "fullName": "jax.numpy.ldexp",
    "signature": "(x1: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], x2: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], /) -> jax.Array",
    "description": "Returns x1 * 2**x2, element-wise."
  },
  "410": {
    "name": "left_shift",
    "module": "jax.numpy",
    "fullName": "jax.numpy.left_shift",
    "signature": "(x1, x2, /)",
    "description": "Shift the bits of an integer to the left."
  },
  "411": {
    "name": "less",
    "module": "jax.numpy",
    "fullName": "jax.numpy.less",
    "signature": "(x1, x2, /)",
    "description": "Return the truth value of (x1 < x2) element-wise."
  },
  "412": {
    "name": "less_equal",
    "module": "jax.numpy",
    "fullName": "jax.numpy.less_equal",
    "signature": "(x1, x2, /)",
    "description": "Return the truth value of (x1 <= x2) element-wise."
  },
  "413": {
    "name": "lexsort",
    "module": "jax.numpy",
    "fullName": "jax.numpy.lexsort",
    "signature": "(keys, axis=-1)",
    "description": "Perform an indirect stable sort using a sequence of keys."
  },
  "414": {
    "name": "linspace",
    "module": "jax.numpy",
    "fullName": "jax.numpy.linspace",
    "signature": "(start: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], stop: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], num: int = 50, endpoint: bool = True, retstep: bool = False, dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType, NoneType] = None, axis: int = 0) -> Union[jax.Array, Tuple[jax.Array, jax.Array]]",
    "description": "Return evenly spaced numbers over a specified interval."
  },
  "415": {
    "name": "load",
    "module": "jax.numpy",
    "fullName": "jax.numpy.load",
    "signature": "(*args: Any, **kwargs: Any) -> jax.Array",
    "description": "Load arrays or pickled objects from ``.npy``, ``.npz`` or pickled files."
  },
  "416": {
    "name": "log",
    "module": "jax.numpy",
    "fullName": "jax.numpy.log",
    "signature": "(x, /)",
    "description": "Natural logarithm, element-wise."
  },
  "417": {
    "name": "log10",
    "module": "jax.numpy",
    "fullName": "jax.numpy.log10",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], /) -> jax.Array",
    "description": "Return the base 10 logarithm of the input array, element-wise."
  },
  "418": {
    "name": "log1p",
    "module": "jax.numpy",
    "fullName": "jax.numpy.log1p",
    "signature": "(x, /)",
    "description": "Return the natural logarithm of one plus the input array, element-wise."
  },
  "419": {
    "name": "log2",
    "module": "jax.numpy",
    "fullName": "jax.numpy.log2",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], /) -> jax.Array",
    "description": "Base-2 logarithm of `x`."
  },
  "420": {
    "name": "logical_and",
    "module": "jax.numpy",
    "fullName": "jax.numpy.logical_and",
    "signature": "(*args)",
    "description": "Compute the truth value of x1 AND x2 element-wise."
  },
  "421": {
    "name": "logical_not",
    "module": "jax.numpy",
    "fullName": "jax.numpy.logical_not",
    "signature": "(*args)",
    "description": "Compute the truth value of NOT x element-wise."
  },
  "422": {
    "name": "logical_or",
    "module": "jax.numpy",
    "fullName": "jax.numpy.logical_or",
    "signature": "(*args)",
    "description": "Compute the truth value of x1 OR x2 element-wise."
  },
  "423": {
    "name": "logical_xor",
    "module": "jax.numpy",
    "fullName": "jax.numpy.logical_xor",
    "signature": "(*args)",
    "description": "Compute the truth value of x1 XOR x2, element-wise."
  },
  "424": {
    "name": "logspace",
    "module": "jax.numpy",
    "fullName": "jax.numpy.logspace",
    "signature": "(start: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], stop: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], num: int = 50, endpoint: bool = True, base: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex] = 10.0, dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType, NoneType] = None, axis: int = 0) -> jax.Array",
    "description": "Return numbers spaced evenly on a log scale."
  },
  "425": {
    "name": "mask_indices",
    "module": "jax.numpy",
    "fullName": "jax.numpy.mask_indices",
    "signature": "(*args, **kwargs)",
    "description": "Return the indices to access (n, n) arrays, given a masking function."
  },
  "426": {
    "name": "matmul",
    "module": "jax.numpy",
    "fullName": "jax.numpy.matmul",
    "signature": "(a, b, *, precision=None)",
    "description": "Matrix product of two arrays."
  },
  "427": {
    "name": "matrix_transpose",
    "module": "jax.numpy",
    "fullName": "jax.numpy.matrix_transpose",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], /) -> jax.Array",
    "description": "Transposes the last two dimensions of x."
  },
  "428": {
    "name": "max",
    "module": "jax.numpy",
    "fullName": "jax.numpy.max",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], axis: Union[NoneType, int, Sequence[int]] = None, out: None = None, keepdims: bool = False, initial: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, NoneType] = None, where: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, NoneType] = None) -> jax.Array",
    "description": "Return the maximum of an array or maximum along an axis."
  },
  "429": {
    "name": "maximum",
    "module": "jax.numpy",
    "fullName": "jax.numpy.maximum",
    "signature": "(x1, x2, /)",
    "description": "Element-wise maximum of array elements."
  },
  "430": {
    "name": "mean",
    "module": "jax.numpy",
    "fullName": "jax.numpy.mean",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], axis: Union[NoneType, int, Sequence[int]] = None, dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType] = None, out: None = None, keepdims: bool = False, *, where: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, NoneType] = None) -> jax.Array",
    "description": "Compute the arithmetic mean along the specified axis."
  },
  "431": {
    "name": "median",
    "module": "jax.numpy",
    "fullName": "jax.numpy.median",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], axis: Union[int, Tuple[int, ...], NoneType] = None, out: None = None, overwrite_input: bool = False, keepdims: bool = False) -> jax.Array",
    "description": "Compute the median along the specified axis."
  },
  "432": {
    "name": "meshgrid",
    "module": "jax.numpy",
    "fullName": "jax.numpy.meshgrid",
    "signature": "(*xi: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], copy: bool = True, sparse: bool = False, indexing: str = 'xy') -> List[jax.Array]",
    "description": "Return a list of coordinate matrices from coordinate vectors."
  },
  "433": {
    "name": "min",
    "module": "jax.numpy",
    "fullName": "jax.numpy.min",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], axis: Union[NoneType, int, Sequence[int]] = None, out: None = None, keepdims: bool = False, initial: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, NoneType] = None, where: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, NoneType] = None) -> jax.Array",
    "description": "Return the minimum of an array or minimum along an axis."
  },
  "434": {
    "name": "minimum",
    "module": "jax.numpy",
    "fullName": "jax.numpy.minimum",
    "signature": "(x1, x2, /)",
    "description": "Element-wise minimum of array elements."
  },
  "435": {
    "name": "mod",
    "module": "jax.numpy",
    "fullName": "jax.numpy.mod",
    "signature": "(x1: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], x2: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], /) -> jax.Array",
    "description": "Returns the element-wise remainder of division."
  },
  "436": {
    "name": "modf",
    "module": "jax.numpy",
    "fullName": "jax.numpy.modf",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], /, out=None) -> Tuple[jax.Array, jax.Array]",
    "description": "Return the fractional and integral parts of an array, element-wise."
  },
  "437": {
    "name": "moveaxis",
    "module": "jax.numpy",
    "fullName": "jax.numpy.moveaxis",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], source: Union[int, Sequence[int]], destination: Union[int, Sequence[int]]) -> jax.Array",
    "description": "Move axes of an array to new positions."
  },
  "438": {
    "name": "multiply",
    "module": "jax.numpy",
    "fullName": "jax.numpy.multiply",
    "signature": "(x1, x2, /)",
    "description": "Multiply arguments element-wise."
  },
  "439": {
    "name": "nan_to_num",
    "module": "jax.numpy",
    "fullName": "jax.numpy.nan_to_num",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], copy: bool = True, nan: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex] = 0.0, posinf: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, NoneType] = None, neginf: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, NoneType] = None) -> jax.Array",
    "description": "Replace NaN with zero and infinity with large finite numbers (default"
  },
  "440": {
    "name": "nanargmax",
    "module": "jax.numpy",
    "fullName": "jax.numpy.nanargmax",
    "signature": "(a, axis: Optional[int] = None, out: Any = None, keepdims: Optional[bool] = None)",
    "description": "Return the indices of the maximum values in the specified axis ignoring"
  },
  "441": {
    "name": "nanargmin",
    "module": "jax.numpy",
    "fullName": "jax.numpy.nanargmin",
    "signature": "(a, axis: Optional[int] = None, out: Any = None, keepdims: Optional[bool] = None)",
    "description": "Return the indices of the minimum values in the specified axis ignoring"
  },
  "442": {
    "name": "nancumprod",
    "module": "jax.numpy",
    "fullName": "jax.numpy.nancumprod",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], axis: Union[NoneType, int, Sequence[int]] = None, dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType] = None, out: None = None) -> jax.Array",
    "description": "Return the cumulative product of array elements over a given axis treating Not a"
  },
  "443": {
    "name": "nancumsum",
    "module": "jax.numpy",
    "fullName": "jax.numpy.nancumsum",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], axis: Union[NoneType, int, Sequence[int]] = None, dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType] = None, out: None = None) -> jax.Array",
    "description": "Return the cumulative sum of array elements over a given axis treating Not a"
  },
  "444": {
    "name": "nanmax",
    "module": "jax.numpy",
    "fullName": "jax.numpy.nanmax",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], axis: Union[NoneType, int, Sequence[int]] = None, out: None = None, keepdims: bool = False, initial: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, NoneType] = None, where: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, NoneType] = None) -> jax.Array",
    "description": "Return the maximum of an array or maximum along an axis, ignoring any"
  },
  "445": {
    "name": "nanmean",
    "module": "jax.numpy",
    "fullName": "jax.numpy.nanmean",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], axis: Union[NoneType, int, Sequence[int]] = None, dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType] = None, out: None = None, keepdims: bool = False, where: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, NoneType] = None) -> jax.Array",
    "description": "Compute the arithmetic mean along the specified axis, ignoring NaNs."
  },
  "446": {
    "name": "nanmedian",
    "module": "jax.numpy",
    "fullName": "jax.numpy.nanmedian",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], axis: Union[int, Tuple[int, ...], NoneType] = None, out: None = None, overwrite_input: bool = False, keepdims: bool = False) -> jax.Array",
    "description": "Compute the median along the specified axis, while ignoring NaNs."
  },
  "447": {
    "name": "nanmin",
    "module": "jax.numpy",
    "fullName": "jax.numpy.nanmin",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], axis: Union[NoneType, int, Sequence[int]] = None, out: None = None, keepdims: bool = False, initial: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, NoneType] = None, where: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, NoneType] = None) -> jax.Array",
    "description": "Return minimum of an array or minimum along an axis, ignoring any NaNs."
  },
  "448": {
    "name": "nanpercentile",
    "module": "jax.numpy",
    "fullName": "jax.numpy.nanpercentile",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], q: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], axis: Union[int, Tuple[int, ...], NoneType] = None, out: None = None, overwrite_input: bool = False, method: str = 'linear', keepdims: bool = False, interpolation: None = None) -> jax.Array",
    "description": "Compute the qth percentile of the data along the specified axis,"
  },
  "449": {
    "name": "nanprod",
    "module": "jax.numpy",
    "fullName": "jax.numpy.nanprod",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], axis: Union[NoneType, int, Sequence[int]] = None, dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType] = None, out: None = None, keepdims: bool = False, initial: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, NoneType] = None, where: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, NoneType] = None) -> jax.Array",
    "description": "Return the product of array elements over a given axis treating Not a"
  },
  "450": {
    "name": "nanquantile",
    "module": "jax.numpy",
    "fullName": "jax.numpy.nanquantile",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], q: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], axis: Union[int, Tuple[int, ...], NoneType] = None, out: None = None, overwrite_input: bool = False, method: str = 'linear', keepdims: bool = False, interpolation: None = None) -> jax.Array",
    "description": "Compute the qth quantile of the data along the specified axis,"
  },
  "451": {
    "name": "nanstd",
    "module": "jax.numpy",
    "fullName": "jax.numpy.nanstd",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], axis: Union[NoneType, int, Sequence[int]] = None, dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType] = None, out: None = None, ddof: int = 0, keepdims: bool = False, where: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, NoneType] = None) -> jax.Array",
    "description": "Compute the standard deviation along the specified axis, while"
  },
  "452": {
    "name": "nansum",
    "module": "jax.numpy",
    "fullName": "jax.numpy.nansum",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], axis: Union[NoneType, int, Sequence[int]] = None, dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType] = None, out: None = None, keepdims: bool = False, initial: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, NoneType] = None, where: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, NoneType] = None) -> jax.Array",
    "description": "Return the sum of array elements over a given axis treating Not a"
  },
  "453": {
    "name": "nanvar",
    "module": "jax.numpy",
    "fullName": "jax.numpy.nanvar",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], axis: Union[NoneType, int, Sequence[int]] = None, dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType] = None, out: None = None, ddof: int = 0, keepdims: bool = False, where: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, NoneType] = None) -> jax.Array",
    "description": "Compute the variance along the specified axis, while ignoring NaNs."
  },
  "454": {
    "name": "negative",
    "module": "jax.numpy",
    "fullName": "jax.numpy.negative",
    "signature": "(x, /)",
    "description": "Numerical negative, element-wise."
  },
  "455": {
    "name": "nextafter",
    "module": "jax.numpy",
    "fullName": "jax.numpy.nextafter",
    "signature": "(x1, x2, /)",
    "description": "Return the next floating-point value after x1 towards x2, element-wise."
  },
  "456": {
    "name": "nonzero",
    "module": "jax.numpy",
    "fullName": "jax.numpy.nonzero",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], *, size: Optional[int] = None, fill_value: Union[NoneType, jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, Tuple[Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]]] = None) -> Tuple[jax.Array, ...]",
    "description": "Return the indices of the elements that are non-zero."
  },
  "457": {
    "name": "not_equal",
    "module": "jax.numpy",
    "fullName": "jax.numpy.not_equal",
    "signature": "(x1, x2, /)",
    "description": "Return (x1 != x2) element-wise."
  },
  "458": {
    "name": "ones",
    "module": "jax.numpy",
    "fullName": "jax.numpy.ones",
    "signature": "(shape: Any, dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType, NoneType] = None) -> jax.Array",
    "description": "Return a new array of given shape and type, filled with ones."
  },
  "459": {
    "name": "ones_like",
    "module": "jax.numpy",
    "fullName": "jax.numpy.ones_like",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, jax._src.DuckTypedArray], dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType, NoneType] = None, shape: Any = None) -> jax.Array",
    "description": "Return an array of ones with the same shape and type as a given array."
  },
  "460": {
    "name": "outer",
    "module": "jax.numpy",
    "fullName": "jax.numpy.outer",
    "signature": "(a, b, out=None)",
    "description": "Compute the outer product of two vectors."
  },
  "461": {
    "name": "packbits",
    "module": "jax.numpy",
    "fullName": "jax.numpy.packbits",
    "signature": "(a, axis: Optional[int] = None, bitorder='big')",
    "description": "Packs the elements of a binary-valued array into bits in a uint8 array."
  },
  "462": {
    "name": "pad",
    "module": "jax.numpy",
    "fullName": "jax.numpy.pad",
    "signature": "(array: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], pad_width: Union[int, Sequence[int], Sequence[Sequence[int]]], mode: Union[str, Callable[..., Any]] = 'constant', **kwargs) -> jax.Array",
    "description": "Pad an array."
  },
  "463": {
    "name": "partition",
    "module": "jax.numpy",
    "fullName": "jax.numpy.partition",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], kth: int, axis: int = -1) -> jax.Array",
    "description": "Return a partitioned copy of an array."
  },
  "464": {
    "name": "percentile",
    "module": "jax.numpy",
    "fullName": "jax.numpy.percentile",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], q: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], axis: Union[int, Tuple[int, ...], NoneType] = None, out: None = None, overwrite_input: bool = False, method: str = 'linear', keepdims: bool = False, interpolation: None = None) -> jax.Array",
    "description": "Compute the q-th percentile of the data along the specified axis."
  },
  "465": {
    "name": "piecewise",
    "module": "jax.numpy",
    "fullName": "jax.numpy.piecewise",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], condlist: Union[jax.Array, Sequence[Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]]], funclist: List[Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, Callable[..., jax.Array]]], *args, **kw) -> jax.Array",
    "description": "Evaluate a piecewise-defined function."
  },
  "466": {
    "name": "place",
    "module": "jax.numpy",
    "fullName": "jax.numpy.place",
    "signature": "(*args, **kwargs)",
    "description": "Change elements of an array based on conditional and input values."
  },
  "467": {
    "name": "poly",
    "module": "jax.numpy",
    "fullName": "jax.numpy.poly",
    "signature": "(seq_of_zeros: jax.Array) -> jax.Array",
    "description": "Find the coefficients of a polynomial with the given sequence of roots."
  },
  "468": {
    "name": "polyadd",
    "module": "jax.numpy",
    "fullName": "jax.numpy.polyadd",
    "signature": "(a1: jax.Array, a2: jax.Array) -> jax.Array",
    "description": "Find the sum of two polynomials."
  },
  "469": {
    "name": "polyder",
    "module": "jax.numpy",
    "fullName": "jax.numpy.polyder",
    "signature": "(p: jax.Array, m: int = 1) -> jax.Array",
    "description": "Return the derivative of the specified order of a polynomial."
  },
  "470": {
    "name": "polydiv",
    "module": "jax.numpy",
    "fullName": "jax.numpy.polydiv",
    "signature": "(u: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], v: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], *, trim_leading_zeros: bool = False) -> Tuple[jax.Array, jax.Array]",
    "description": "Returns the quotient and remainder of polynomial division."
  },
  "471": {
    "name": "polyfit",
    "module": "jax.numpy",
    "fullName": "jax.numpy.polyfit",
    "signature": "(x: jax.Array, y: jax.Array, deg: int, rcond: Optional[float] = None, full: bool = False, w: Optional[jax.Array] = None, cov: bool = False) -> Union[jax.Array, Tuple[jax.Array, ...]]",
    "description": "Least squares polynomial fit."
  },
  "472": {
    "name": "polyint",
    "module": "jax.numpy",
    "fullName": "jax.numpy.polyint",
    "signature": "(p: jax.Array, m: int = 1, k: Optional[int] = None) -> jax.Array",
    "description": "Return an antiderivative (indefinite integral) of a polynomial."
  },
  "473": {
    "name": "polymul",
    "module": "jax.numpy",
    "fullName": "jax.numpy.polymul",
    "signature": "(a1: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], a2: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], *, trim_leading_zeros: bool = False) -> jax.Array",
    "description": "Find the product of two polynomials."
  },
  "474": {
    "name": "polysub",
    "module": "jax.numpy",
    "fullName": "jax.numpy.polysub",
    "signature": "(a1: jax.Array, a2: jax.Array) -> jax.Array",
    "description": "Difference (subtraction) of two polynomials."
  },
  "475": {
    "name": "polyval",
    "module": "jax.numpy",
    "fullName": "jax.numpy.polyval",
    "signature": "(p: jax.Array, x: jax.Array, *, unroll: int = 16) -> jax.Array",
    "description": "Evaluate a polynomial at specific values."
  },
  "476": {
    "name": "positive",
    "module": "jax.numpy",
    "fullName": "jax.numpy.positive",
    "signature": "(x, /)",
    "description": "Numerical positive, element-wise."
  },
  "477": {
    "name": "power",
    "module": "jax.numpy",
    "fullName": "jax.numpy.power",
    "signature": "(x1: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], x2: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], /) -> jax.Array",
    "description": "First array elements raised to powers from second array, element-wise."
  },
  "478": {
    "name": "printoptions",
    "module": "jax.numpy",
    "fullName": "jax.numpy.printoptions",
    "signature": "(*args, **kwargs)",
    "description": "Context manager for setting print options."
  },
  "479": {
    "name": "prod",
    "module": "jax.numpy",
    "fullName": "jax.numpy.prod",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], axis: Union[NoneType, int, Sequence[int]] = None, dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType] = None, out: None = None, keepdims: bool = False, initial: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, NoneType] = None, where: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, NoneType] = None, promote_integers: bool = True) -> jax.Array",
    "description": "Return the product of array elements over a given axis."
  },
  "480": {
    "name": "promote_types",
    "module": "jax.numpy",
    "fullName": "jax.numpy.promote_types",
    "signature": "(a: Union[Any, str, numpy.dtype, jax._src.SupportsDType], b: Union[Any, str, numpy.dtype, jax._src.SupportsDType]) -> numpy.dtype",
    "description": "Returns the type to which a binary operation should cast its arguments."
  },
  "481": {
    "name": "ptp",
    "module": "jax.numpy",
    "fullName": "jax.numpy.ptp",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], axis: Union[NoneType, int, Sequence[int]] = None, out: None = None, keepdims: bool = False) -> jax.Array",
    "description": "Range of values (maximum - minimum) along an axis."
  },
  "482": {
    "name": "put",
    "module": "jax.numpy",
    "fullName": "jax.numpy.put",
    "signature": "(*args, **kwargs)",
    "description": "Replaces specified elements of an array with given values."
  },
  "483": {
    "name": "quantile",
    "module": "jax.numpy",
    "fullName": "jax.numpy.quantile",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], q: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], axis: Union[int, Tuple[int, ...], NoneType] = None, out: None = None, overwrite_input: bool = False, method: str = 'linear', keepdims: bool = False, interpolation: None = None) -> jax.Array",
    "description": "Compute the q-th quantile of the data along the specified axis."
  },
  "484": {
    "name": "rad2deg",
    "module": "jax.numpy",
    "fullName": "jax.numpy.rad2deg",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], /) -> jax.Array",
    "description": "Convert angles from radians to degrees."
  },
  "485": {
    "name": "radians",
    "module": "jax.numpy",
    "fullName": "jax.numpy.radians",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], /) -> jax.Array",
    "description": "Convert angles from degrees to radians."
  },
  "486": {
    "name": "ravel",
    "module": "jax.numpy",
    "fullName": "jax.numpy.ravel",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], order: str = 'C') -> jax.Array",
    "description": "Return a contiguous flattened array."
  },
  "487": {
    "name": "ravel_multi_index",
    "module": "jax.numpy",
    "fullName": "jax.numpy.ravel_multi_index",
    "signature": "(multi_index: Tuple[Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], ...], dims: Tuple[int, ...], mode: str = 'raise', order: str = 'C') -> jax.Array",
    "description": "Converts a tuple of index arrays into an array of flat"
  },
  "488": {
    "name": "real",
    "module": "jax.numpy",
    "fullName": "jax.numpy.real",
    "signature": "(val: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], /) -> jax.Array",
    "description": "Return the real part of the complex argument."
  },
  "489": {
    "name": "reciprocal",
    "module": "jax.numpy",
    "fullName": "jax.numpy.reciprocal",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], /) -> jax.Array",
    "description": "Return the reciprocal of the argument, element-wise."
  },
  "490": {
    "name": "remainder",
    "module": "jax.numpy",
    "fullName": "jax.numpy.remainder",
    "signature": "(x1: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], x2: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], /) -> jax.Array",
    "description": "Returns the element-wise remainder of division."
  },
  "491": {
    "name": "repeat",
    "module": "jax.numpy",
    "fullName": "jax.numpy.repeat",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], repeats: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], axis: Optional[int] = None, *, total_repeat_length: Optional[int] = None) -> jax.Array",
    "description": "Repeat each element of an array after themselves"
  },
  "492": {
    "name": "reshape",
    "module": "jax.numpy",
    "fullName": "jax.numpy.reshape",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], newshape: Union[int, Any, Sequence[Union[int, Any]]], order: str = 'C') -> jax.Array",
    "description": "Gives a new shape to an array without changing its data."
  },
  "493": {
    "name": "resize",
    "module": "jax.numpy",
    "fullName": "jax.numpy.resize",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], new_shape: Sequence[Union[int, Any]]) -> jax.Array",
    "description": "Return a new array with the specified shape."
  },
  "494": {
    "name": "result_type",
    "module": "jax.numpy",
    "fullName": "jax.numpy.result_type",
    "signature": "(*args: Any) -> numpy.dtype",
    "description": "Returns the type that results from applying the NumPy"
  },
  "495": {
    "name": "right_shift",
    "module": "jax.numpy",
    "fullName": "jax.numpy.right_shift",
    "signature": "(x1: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], x2: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], /) -> jax.Array",
    "description": "Shift the bits of an integer to the right."
  },
  "496": {
    "name": "rint",
    "module": "jax.numpy",
    "fullName": "jax.numpy.rint",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], /) -> jax.Array",
    "description": "Round elements of the array to the nearest integer."
  },
  "497": {
    "name": "roll",
    "module": "jax.numpy",
    "fullName": "jax.numpy.roll",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], shift: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, Sequence[int]], axis: Union[int, Sequence[int], NoneType] = None) -> jax.Array",
    "description": "Roll array elements along a given axis."
  },
  "498": {
    "name": "rollaxis",
    "module": "jax.numpy",
    "fullName": "jax.numpy.rollaxis",
    "signature": "(a, axis: int, start=0)",
    "description": "Roll the specified axis backwards, until it lies in a given position."
  },
  "499": {
    "name": "roots",
    "module": "jax.numpy",
    "fullName": "jax.numpy.roots",
    "signature": "(p: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], *, strip_zeros: bool = True) -> jax.Array",
    "description": "Return the roots of a polynomial with coefficients given in p."
  },
  "500": {
    "name": "rot90",
    "module": "jax.numpy",
    "fullName": "jax.numpy.rot90",
    "signature": "(m: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], k: int = 1, axes: Tuple[int, int] = (0, 1)) -> jax.Array",
    "description": "Rotate an array by 90 degrees in the plane specified by axes."
  },
  "501": {
    "name": "round",
    "module": "jax.numpy",
    "fullName": "jax.numpy.round",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], decimals: int = 0, out: None = None) -> jax.Array",
    "description": "Round an array to the given number of decimals."
  },
  "502": {
    "name": "round_",
    "module": "jax.numpy",
    "fullName": "jax.numpy.round_",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], decimals: int = 0, out: None = None) -> jax.Array",
    "description": "Round an array to the given number of decimals."
  },
  "503": {
    "name": "row_stack",
    "module": "jax.numpy",
    "fullName": "jax.numpy.row_stack",
    "signature": "(tup: Union[numpy.ndarray, jax.Array, Sequence[Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]]], dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType, NoneType] = None) -> jax.Array",
    "description": "Stack arrays in sequence vertically (row wise)."
  },
  "504": {
    "name": "searchsorted",
    "module": "jax.numpy",
    "fullName": "jax.numpy.searchsorted",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], v: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], side: str = 'left', sorter: None = None, *, method: str = 'scan') -> jax.Array",
    "description": "Find indices where elements should be inserted to maintain order."
  },
  "505": {
    "name": "select",
    "module": "jax.numpy",
    "fullName": "jax.numpy.select",
    "signature": "(condlist, choicelist, default=0)",
    "description": "Return an array drawn from elements in choicelist, depending on conditions."
  },
  "506": {
    "name": "set_printoptions",
    "module": "jax.numpy",
    "fullName": "jax.numpy.set_printoptions",
    "signature": "(precision=None, threshold=None, edgeitems=None, linewidth=None, suppress=None, nanstr=None, infstr=None, formatter=None, sign=None, floatmode=None, *, legacy=None)",
    "description": "Set printing options."
  },
  "507": {
    "name": "setdiff1d",
    "module": "jax.numpy",
    "fullName": "jax.numpy.setdiff1d",
    "signature": "(ar1: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], ar2: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], assume_unique: bool = False, *, size: Optional[int] = None, fill_value: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, NoneType] = None) -> jax.Array",
    "description": "Find the set difference of two arrays."
  },
  "508": {
    "name": "setxor1d",
    "module": "jax.numpy",
    "fullName": "jax.numpy.setxor1d",
    "signature": "(ar1: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], ar2: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], assume_unique: bool = False) -> jax.Array",
    "description": "Find the set exclusive-or of two arrays."
  },
  "509": {
    "name": "sign",
    "module": "jax.numpy",
    "fullName": "jax.numpy.sign",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], /) -> jax.Array",
    "description": "Returns an element-wise indication of the sign of a number."
  },
  "510": {
    "name": "signbit",
    "module": "jax.numpy",
    "fullName": "jax.numpy.signbit",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], /) -> jax.Array",
    "description": "Returns element-wise True where signbit is set (less than zero)."
  },
  "511": {
    "name": "sin",
    "module": "jax.numpy",
    "fullName": "jax.numpy.sin",
    "signature": "(x, /)",
    "description": "Trigonometric sine, element-wise."
  },
  "512": {
    "name": "sinc",
    "module": "jax.numpy",
    "fullName": "jax.numpy.sinc",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], /) -> jax.Array",
    "description": "Return the normalized sinc function."
  },
  "513": {
    "name": "sinh",
    "module": "jax.numpy",
    "fullName": "jax.numpy.sinh",
    "signature": "(x, /)",
    "description": "Hyperbolic sine, element-wise."
  },
  "514": {
    "name": "sort",
    "module": "jax.numpy",
    "fullName": "jax.numpy.sort",
    "signature": "(a, axis: Optional[int] = -1, kind='quicksort', order=None)",
    "description": "Return a sorted copy of an array."
  },
  "515": {
    "name": "sort_complex",
    "module": "jax.numpy",
    "fullName": "jax.numpy.sort_complex",
    "signature": "(a)",
    "description": "Sort a complex array using the real part first, then the imaginary part."
  },
  "516": {
    "name": "split",
    "module": "jax.numpy",
    "fullName": "jax.numpy.split",
    "signature": "(ary: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], indices_or_sections: Union[int, Sequence[int], jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, float, complex], axis: int = 0) -> List[jax.Array]",
    "description": "Split an array into multiple sub-arrays as views into `ary`."
  },
  "517": {
    "name": "sqrt",
    "module": "jax.numpy",
    "fullName": "jax.numpy.sqrt",
    "signature": "(x, /)",
    "description": "Return the non-negative square-root of an array, element-wise."
  },
  "518": {
    "name": "square",
    "module": "jax.numpy",
    "fullName": "jax.numpy.square",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], /) -> jax.Array",
    "description": "Return the element-wise square of the input."
  },
  "519": {
    "name": "squeeze",
    "module": "jax.numpy",
    "fullName": "jax.numpy.squeeze",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], axis: Union[int, Tuple[int, ...], NoneType] = None) -> jax.Array",
    "description": "Remove axes of length one from `a`."
  },
  "520": {
    "name": "stack",
    "module": "jax.numpy",
    "fullName": "jax.numpy.stack",
    "signature": "(arrays: Union[numpy.ndarray, jax.Array, Sequence[Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]]], axis: int = 0, out: None = None, dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType, NoneType] = None) -> jax.Array",
    "description": "Join a sequence of arrays along a new axis."
  },
  "521": {
    "name": "std",
    "module": "jax.numpy",
    "fullName": "jax.numpy.std",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], axis: Union[NoneType, int, Sequence[int]] = None, dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType] = None, out: None = None, ddof: int = 0, keepdims: bool = False, *, where: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, NoneType] = None) -> jax.Array",
    "description": "Compute the standard deviation along the specified axis."
  },
  "522": {
    "name": "subtract",
    "module": "jax.numpy",
    "fullName": "jax.numpy.subtract",
    "signature": "(x1, x2, /)",
    "description": "Subtract arguments, element-wise."
  },
  "523": {
    "name": "sum",
    "module": "jax.numpy",
    "fullName": "jax.numpy.sum",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], axis: Union[NoneType, int, Sequence[int]] = None, dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType] = None, out: None = None, keepdims: bool = False, initial: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, NoneType] = None, where: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, NoneType] = None, promote_integers: bool = True) -> jax.Array",
    "description": "Sum of array elements over a given axis."
  },
  "524": {
    "name": "swapaxes",
    "module": "jax.numpy",
    "fullName": "jax.numpy.swapaxes",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], axis1: int, axis2: int) -> jax.Array",
    "description": "Interchange two axes of an array."
  },
  "525": {
    "name": "take",
    "module": "jax.numpy",
    "fullName": "jax.numpy.take",
    "signature": "(a, indices, axis: Optional[int] = None, out=None, mode=None, unique_indices=False, indices_are_sorted=False, fill_value=None)",
    "description": "Take elements from an array along an axis."
  },
  "526": {
    "name": "take_along_axis",
    "module": "jax.numpy",
    "fullName": "jax.numpy.take_along_axis",
    "signature": "(arr, indices, axis: Optional[int], mode: Union[str, jax._src.lax.slicing.GatherScatterMode, NoneType] = None)",
    "description": "Take values from the input array by matching 1d index and data slices."
  },
  "527": {
    "name": "tan",
    "module": "jax.numpy",
    "fullName": "jax.numpy.tan",
    "signature": "(x, /)",
    "description": "Compute tangent element-wise."
  },
  "528": {
    "name": "tanh",
    "module": "jax.numpy",
    "fullName": "jax.numpy.tanh",
    "signature": "(x, /)",
    "description": "Compute hyperbolic tangent element-wise."
  },
  "529": {
    "name": "tensordot",
    "module": "jax.numpy",
    "fullName": "jax.numpy.tensordot",
    "signature": "(a, b, axes=2, *, precision=None)",
    "description": "Compute tensor dot product along specified axes."
  },
  "530": {
    "name": "tile",
    "module": "jax.numpy",
    "fullName": "jax.numpy.tile",
    "signature": "(A: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], reps: Union[int, Any, Sequence[Union[int, Any]]]) -> jax.Array",
    "description": "Construct an array by repeating A the number of times given by reps."
  },
  "531": {
    "name": "trace",
    "module": "jax.numpy",
    "fullName": "jax.numpy.trace",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], offset: int = 0, axis1: int = 0, axis2: int = 1, dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType, NoneType] = None, out: None = None) -> jax.Array",
    "description": "Return the sum along diagonals of the array."
  },
  "532": {
    "name": "transpose",
    "module": "jax.numpy",
    "fullName": "jax.numpy.transpose",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], axes: Optional[Sequence[int]] = None) -> jax.Array",
    "description": "Returns an array with axes transposed."
  },
  "533": {
    "name": "trapz",
    "module": "jax.numpy",
    "fullName": "jax.numpy.trapz",
    "signature": "(y: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, NoneType] = None, dx: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex] = 1.0, axis: int = -1) -> jax.Array",
    "description": "Integrate along the given axis using the composite trapezoidal rule."
  },
  "534": {
    "name": "tri",
    "module": "jax.numpy",
    "fullName": "jax.numpy.tri",
    "signature": "(N: int, M: Optional[int] = None, k: int = 0, dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType] = None) -> jax.Array",
    "description": "An array with ones at and below the given diagonal and zeros elsewhere."
  },
  "535": {
    "name": "tril",
    "module": "jax.numpy",
    "fullName": "jax.numpy.tril",
    "signature": "(m: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], k: int = 0) -> jax.Array",
    "description": "Lower triangle of an array."
  },
  "536": {
    "name": "tril_indices",
    "module": "jax.numpy",
    "fullName": "jax.numpy.tril_indices",
    "signature": "(n: int, k: int = 0, m: Optional[int] = None) -> Tuple[jax.Array, jax.Array]",
    "description": "Return the indices for the lower-triangle of an (n, m) array."
  },
  "537": {
    "name": "tril_indices_from",
    "module": "jax.numpy",
    "fullName": "jax.numpy.tril_indices_from",
    "signature": "(arr: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], k: int = 0) -> Tuple[jax.Array, jax.Array]",
    "description": "Return the indices for the lower-triangle of arr."
  },
  "538": {
    "name": "trim_zeros",
    "module": "jax.numpy",
    "fullName": "jax.numpy.trim_zeros",
    "signature": "(filt, trim='fb')",
    "description": "Trim the leading and/or trailing zeros from a 1-D array or sequence."
  },
  "539": {
    "name": "triu",
    "module": "jax.numpy",
    "fullName": "jax.numpy.triu",
    "signature": "(m: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], k: int = 0) -> jax.Array",
    "description": "Upper triangle of an array."
  },
  "540": {
    "name": "triu_indices",
    "module": "jax.numpy",
    "fullName": "jax.numpy.triu_indices",
    "signature": "(n: int, k: int = 0, m: Optional[int] = None) -> Tuple[jax.Array, jax.Array]",
    "description": "Return the indices for the upper-triangle of an (n, m) array."
  },
  "541": {
    "name": "triu_indices_from",
    "module": "jax.numpy",
    "fullName": "jax.numpy.triu_indices_from",
    "signature": "(arr: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], k: int = 0) -> Tuple[jax.Array, jax.Array]",
    "description": "Return the indices for the upper-triangle of arr."
  },
  "542": {
    "name": "true_divide",
    "module": "jax.numpy",
    "fullName": "jax.numpy.true_divide",
    "signature": "(x1: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], x2: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], /) -> jax.Array",
    "description": "Divide arguments element-wise."
  },
  "543": {
    "name": "trunc",
    "module": "jax.numpy",
    "fullName": "jax.numpy.trunc",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Return the truncated value of the input, element-wise."
  },
  "544": {
    "name": "union1d",
    "module": "jax.numpy",
    "fullName": "jax.numpy.union1d",
    "signature": "(ar1: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], ar2: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], *, size: Optional[int] = None, fill_value: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, NoneType] = None) -> jax.Array",
    "description": "Find the union of two arrays."
  },
  "545": {
    "name": "unique",
    "module": "jax.numpy",
    "fullName": "jax.numpy.unique",
    "signature": "(ar: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], return_index: bool = False, return_inverse: bool = False, return_counts: bool = False, axis: Optional[int] = None, *, size: Optional[int] = None, fill_value: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, NoneType] = None)",
    "description": "Find the unique elements of an array."
  },
  "546": {
    "name": "unpackbits",
    "module": "jax.numpy",
    "fullName": "jax.numpy.unpackbits",
    "signature": "(a, axis: Optional[int] = None, count=None, bitorder='big')",
    "description": "Unpacks elements of a uint8 array into a binary-valued output array."
  },
  "547": {
    "name": "unravel_index",
    "module": "jax.numpy",
    "fullName": "jax.numpy.unravel_index",
    "signature": "(indices: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], shape: Sequence[Union[int, Any]]) -> Tuple[jax.Array, ...]",
    "description": "Converts a flat index or array of flat indices into a tuple"
  },
  "548": {
    "name": "unwrap",
    "module": "jax.numpy",
    "fullName": "jax.numpy.unwrap",
    "signature": "(p: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], discont: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, NoneType] = None, axis: int = -1, period: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex] = 6.283185307179586) -> jax.Array",
    "description": "Unwrap by taking the complement of large deltas with respect to the period."
  },
  "549": {
    "name": "vander",
    "module": "jax.numpy",
    "fullName": "jax.numpy.vander",
    "signature": "(x, N=None, increasing=False)",
    "description": "Generate a Vandermonde matrix."
  },
  "550": {
    "name": "var",
    "module": "jax.numpy",
    "fullName": "jax.numpy.var",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], axis: Union[NoneType, int, Sequence[int]] = None, dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType] = None, out: None = None, ddof: int = 0, keepdims: bool = False, *, where: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, NoneType] = None) -> jax.Array",
    "description": "Compute the variance along the specified axis."
  },
  "551": {
    "name": "vdot",
    "module": "jax.numpy",
    "fullName": "jax.numpy.vdot",
    "signature": "(a, b, *, precision=None)",
    "description": "Return the dot product of two vectors."
  },
  "552": {
    "name": "vectorize",
    "module": "jax.numpy",
    "fullName": "jax.numpy.vectorize",
    "signature": "(pyfunc, *, excluded=frozenset(), signature=None)",
    "description": "Define a vectorized function with broadcasting."
  },
  "553": {
    "name": "vsplit",
    "module": "jax.numpy",
    "fullName": "jax.numpy.vsplit",
    "signature": "(ary: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], indices_or_sections: Union[int, Sequence[int], jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, float, complex]) -> List[jax.Array]",
    "description": "Split an array into multiple sub-arrays vertically (row-wise)."
  },
  "554": {
    "name": "vstack",
    "module": "jax.numpy",
    "fullName": "jax.numpy.vstack",
    "signature": "(tup: Union[numpy.ndarray, jax.Array, Sequence[Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]]], dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType, NoneType] = None) -> jax.Array",
    "description": "Stack arrays in sequence vertically (row wise)."
  },
  "555": {
    "name": "where",
    "module": "jax.numpy",
    "fullName": "jax.numpy.where",
    "signature": "(condition: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, NoneType] = None, y: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, NoneType] = None, *, size: Optional[int] = None, fill_value: Union[NoneType, jax.Array, Tuple[Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]]] = None) -> Union[jax.Array, Tuple[jax.Array, ...]]",
    "description": "Return elements chosen from `x` or `y` depending on `condition`."
  },
  "556": {
    "name": "zeros",
    "module": "jax.numpy",
    "fullName": "jax.numpy.zeros",
    "signature": "(shape: Any, dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType, NoneType] = None) -> jax.Array",
    "description": "Return a new array of given shape and type, filled with zeros."
  },
  "557": {
    "name": "zeros_like",
    "module": "jax.numpy",
    "fullName": "jax.numpy.zeros_like",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, jax._src.DuckTypedArray], dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType, NoneType] = None, shape: Any = None) -> jax.Array",
    "description": "Return an array of zeros with the same shape and type as a given array."
  },
  "558": {
    "name": "cholesky",
    "module": "jax.numpy.linalg",
    "fullName": "jax.numpy.linalg.cholesky",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Cholesky decomposition."
  },
  "559": {
    "name": "cond",
    "module": "jax.numpy.linalg",
    "fullName": "jax.numpy.linalg.cond",
    "signature": "(x, p=None)",
    "description": "Compute the condition number of a matrix."
  },
  "560": {
    "name": "eig",
    "module": "jax.numpy.linalg",
    "fullName": "jax.numpy.linalg.eig",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> Tuple[jax.Array, jax.Array]",
    "description": "Compute the eigenvalues and right eigenvectors of a square array."
  },
  "561": {
    "name": "eigh",
    "module": "jax.numpy.linalg",
    "fullName": "jax.numpy.linalg.eigh",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], UPLO: Optional[str] = None, symmetrize_input: bool = True) -> Tuple[jax.Array, jax.Array]",
    "description": "Return the eigenvalues and eigenvectors of a complex Hermitian"
  },
  "562": {
    "name": "eigvals",
    "module": "jax.numpy.linalg",
    "fullName": "jax.numpy.linalg.eigvals",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Compute the eigenvalues of a general matrix."
  },
  "563": {
    "name": "eigvalsh",
    "module": "jax.numpy.linalg",
    "fullName": "jax.numpy.linalg.eigvalsh",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], UPLO: Optional[str] = 'L') -> jax.Array",
    "description": "Compute the eigenvalues of a complex Hermitian or real symmetric matrix."
  },
  "564": {
    "name": "inv",
    "module": "jax.numpy.linalg",
    "fullName": "jax.numpy.linalg.inv",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Compute the (multiplicative) inverse of a matrix."
  },
  "565": {
    "name": "lstsq",
    "module": "jax.numpy.linalg",
    "fullName": "jax.numpy.linalg.lstsq",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], b: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], rcond: Optional[float] = None, *, numpy_resid: bool = False) -> Tuple[jax.Array, jax.Array, jax.Array, jax.Array]",
    "description": "Return the least-squares solution to a linear matrix equation."
  },
  "566": {
    "name": "matrix_power",
    "module": "jax.numpy.linalg",
    "fullName": "jax.numpy.linalg.matrix_power",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], n: int) -> jax.Array",
    "description": "Raise a square matrix to the (integer) power `n`."
  },
  "567": {
    "name": "matrix_rank",
    "module": "jax.numpy.linalg",
    "fullName": "jax.numpy.linalg.matrix_rank",
    "signature": "(M: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], tol: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, NoneType] = None) -> jax.Array",
    "description": "Return matrix rank of array using SVD method"
  },
  "568": {
    "name": "multi_dot",
    "module": "jax.numpy.linalg",
    "fullName": "jax.numpy.linalg.multi_dot",
    "signature": "(arrays, *, precision=None)",
    "description": "Compute the dot product of two or more arrays in a single function call,"
  },
  "569": {
    "name": "norm",
    "module": "jax.numpy.linalg",
    "fullName": "jax.numpy.linalg.norm",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], ord: Union[int, str, NoneType] = None, axis: Union[NoneType, Tuple[int, ...], int] = None, keepdims: bool = False) -> jax.Array",
    "description": "Matrix or vector norm."
  },
  "570": {
    "name": "qr",
    "module": "jax.numpy.linalg",
    "fullName": "jax.numpy.linalg.qr",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], mode: str = 'reduced') -> Union[jax.Array, Tuple[jax.Array, jax.Array]]",
    "description": "Compute the qr factorization of a matrix."
  },
  "571": {
    "name": "slogdet",
    "module": "jax.numpy.linalg",
    "fullName": "jax.numpy.linalg.slogdet",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], *, method: Optional[str] = None) -> Tuple[jax.Array, jax.Array]",
    "description": "Compute the sign and (natural) logarithm of the determinant of an array."
  },
  "572": {
    "name": "solve",
    "module": "jax.numpy.linalg",
    "fullName": "jax.numpy.linalg.solve",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], b: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Solve a linear matrix equation, or system of linear scalar equations."
  },
  "573": {
    "name": "svd",
    "module": "jax.numpy.linalg",
    "fullName": "jax.numpy.linalg.svd",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], full_matrices: bool = True, compute_uv: bool = True, hermitian: bool = False) -> Union[jax.Array, Tuple[jax.Array, jax.Array, jax.Array]]",
    "description": "Singular Value Decomposition."
  },
  "574": {
    "name": "tensorinv",
    "module": "jax.numpy.linalg",
    "fullName": "jax.numpy.linalg.tensorinv",
    "signature": "(a, ind=2)",
    "description": "Compute the 'inverse' of an N-dimensional array."
  },
  "575": {
    "name": "tensorsolve",
    "module": "jax.numpy.linalg",
    "fullName": "jax.numpy.linalg.tensorsolve",
    "signature": "(a, b, axes=None)",
    "description": "Solve the tensor equation ``a x = b`` for x."
  },
  "576": {
    "name": "fft",
    "module": "jax.numpy.fft",
    "fullName": "jax.numpy.fft.fft",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], n: Optional[int] = None, axis: int = -1, norm: Optional[str] = None) -> jax.Array",
    "description": "Compute the one-dimensional discrete Fourier Transform."
  },
  "577": {
    "name": "fft2",
    "module": "jax.numpy.fft",
    "fullName": "jax.numpy.fft.fft2",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], s: Optional[Sequence[int]] = None, axes: Sequence[int] = (-2, -1), norm: Optional[str] = None) -> jax.Array",
    "description": "Compute the 2-dimensional discrete Fourier Transform."
  },
  "578": {
    "name": "fftfreq",
    "module": "jax.numpy.fft",
    "fullName": "jax.numpy.fft.fftfreq",
    "signature": "(n: int, d: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex] = 1.0, *, dtype=None) -> jax.Array",
    "description": "Return the Discrete Fourier Transform sample frequencies."
  },
  "579": {
    "name": "fftn",
    "module": "jax.numpy.fft",
    "fullName": "jax.numpy.fft.fftn",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], s: Optional[Sequence[int]] = None, axes: Optional[Sequence[int]] = None, norm: Optional[str] = None) -> jax.Array",
    "description": "Compute the N-dimensional discrete Fourier Transform."
  },
  "580": {
    "name": "fftshift",
    "module": "jax.numpy.fft",
    "fullName": "jax.numpy.fft.fftshift",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], axes: Union[NoneType, int, Sequence[int]] = None) -> jax.Array",
    "description": "Shift the zero-frequency component to the center of the spectrum."
  },
  "581": {
    "name": "hfft",
    "module": "jax.numpy.fft",
    "fullName": "jax.numpy.fft.hfft",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], n: Optional[int] = None, axis: int = -1, norm: Optional[str] = None) -> jax.Array",
    "description": "Compute the FFT of a signal that has Hermitian symmetry, i.e., a real"
  },
  "582": {
    "name": "ifft",
    "module": "jax.numpy.fft",
    "fullName": "jax.numpy.fft.ifft",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], n: Optional[int] = None, axis: int = -1, norm: Optional[str] = None) -> jax.Array",
    "description": "Compute the one-dimensional inverse discrete Fourier Transform."
  },
  "583": {
    "name": "ifft2",
    "module": "jax.numpy.fft",
    "fullName": "jax.numpy.fft.ifft2",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], s: Optional[Sequence[int]] = None, axes: Sequence[int] = (-2, -1), norm: Optional[str] = None) -> jax.Array",
    "description": "Compute the 2-dimensional inverse discrete Fourier Transform."
  },
  "584": {
    "name": "ifftn",
    "module": "jax.numpy.fft",
    "fullName": "jax.numpy.fft.ifftn",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], s: Optional[Sequence[int]] = None, axes: Optional[Sequence[int]] = None, norm: Optional[str] = None) -> jax.Array",
    "description": "Compute the N-dimensional inverse discrete Fourier Transform."
  },
  "585": {
    "name": "ifftshift",
    "module": "jax.numpy.fft",
    "fullName": "jax.numpy.fft.ifftshift",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], axes: Union[NoneType, int, Sequence[int]] = None) -> jax.Array",
    "description": "The inverse of `fftshift`. Although identical for even-length `x`, the"
  },
  "586": {
    "name": "ihfft",
    "module": "jax.numpy.fft",
    "fullName": "jax.numpy.fft.ihfft",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], n: Optional[int] = None, axis: int = -1, norm: Optional[str] = None) -> jax.Array",
    "description": "Compute the inverse FFT of a signal that has Hermitian symmetry."
  },
  "587": {
    "name": "irfft",
    "module": "jax.numpy.fft",
    "fullName": "jax.numpy.fft.irfft",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], n: Optional[int] = None, axis: int = -1, norm: Optional[str] = None) -> jax.Array",
    "description": "Computes the inverse of `rfft`."
  },
  "588": {
    "name": "irfft2",
    "module": "jax.numpy.fft",
    "fullName": "jax.numpy.fft.irfft2",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], s: Optional[Sequence[int]] = None, axes: Sequence[int] = (-2, -1), norm: Optional[str] = None) -> jax.Array",
    "description": "Computes the inverse of `rfft2`."
  },
  "589": {
    "name": "irfftn",
    "module": "jax.numpy.fft",
    "fullName": "jax.numpy.fft.irfftn",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], s: Optional[Sequence[int]] = None, axes: Optional[Sequence[int]] = None, norm: Optional[str] = None) -> jax.Array",
    "description": "Computes the inverse of `rfftn`."
  },
  "590": {
    "name": "rfft",
    "module": "jax.numpy.fft",
    "fullName": "jax.numpy.fft.rfft",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], n: Optional[int] = None, axis: int = -1, norm: Optional[str] = None) -> jax.Array",
    "description": "Compute the one-dimensional discrete Fourier Transform for real input."
  },
  "591": {
    "name": "rfft2",
    "module": "jax.numpy.fft",
    "fullName": "jax.numpy.fft.rfft2",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], s: Optional[Sequence[int]] = None, axes: Sequence[int] = (-2, -1), norm: Optional[str] = None) -> jax.Array",
    "description": "Compute the 2-dimensional FFT of a real array."
  },
  "592": {
    "name": "rfftfreq",
    "module": "jax.numpy.fft",
    "fullName": "jax.numpy.fft.rfftfreq",
    "signature": "(n: int, d: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex] = 1.0, *, dtype=None) -> jax.Array",
    "description": "Return the Discrete Fourier Transform sample frequencies"
  },
  "593": {
    "name": "rfftn",
    "module": "jax.numpy.fft",
    "fullName": "jax.numpy.fft.rfftn",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], s: Optional[Sequence[int]] = None, axes: Optional[Sequence[int]] = None, norm: Optional[str] = None) -> jax.Array",
    "description": "Compute the N-dimensional discrete Fourier Transform for real input."
  },
  "594": {
    "name": "celu",
    "module": "jax.nn",
    "fullName": "jax.nn.celu",
    "signature": "(x: Any, alpha: Any = 1.0) -> Any",
    "description": "Continuously-differentiable exponential linear unit activation."
  },
  "595": {
    "name": "elu",
    "module": "jax.nn",
    "fullName": "jax.nn.elu",
    "signature": "(x: Any, alpha: Any = 1.0) -> Any",
    "description": "Exponential linear unit activation function."
  },
  "596": {
    "name": "gelu",
    "module": "jax.nn",
    "fullName": "jax.nn.gelu",
    "signature": "(x: Any, approximate: bool = True) -> Any",
    "description": "Gaussian error linear unit activation function."
  },
  "597": {
    "name": "glu",
    "module": "jax.nn",
    "fullName": "jax.nn.glu",
    "signature": "(x: Any, axis: int = -1) -> Any",
    "description": "Gated linear unit activation function."
  },
  "598": {
    "name": "hard_sigmoid",
    "module": "jax.nn",
    "fullName": "jax.nn.hard_sigmoid",
    "signature": "(x: Any) -> Any",
    "description": "Hard Sigmoid activation function."
  },
  "599": {
    "name": "hard_silu",
    "module": "jax.nn",
    "fullName": "jax.nn.hard_silu",
    "signature": "(x: Any) -> Any",
    "description": "Hard SiLU activation function"
  },
  "600": {
    "name": "hard_swish",
    "module": "jax.nn",
    "fullName": "jax.nn.hard_swish",
    "signature": "(x: Any) -> Any",
    "description": "Hard SiLU activation function"
  },
  "601": {
    "name": "hard_tanh",
    "module": "jax.nn",
    "fullName": "jax.nn.hard_tanh",
    "signature": "(x: Any) -> Any",
    "description": "Hard :math:`\\mathrm{tanh}` activation function."
  },
  "602": {
    "name": "leaky_relu",
    "module": "jax.nn",
    "fullName": "jax.nn.leaky_relu",
    "signature": "(x: Any, negative_slope: Any = 0.01) -> Any",
    "description": "Leaky rectified linear unit activation function."
  },
  "603": {
    "name": "log_sigmoid",
    "module": "jax.nn",
    "fullName": "jax.nn.log_sigmoid",
    "signature": "(x: Any) -> Any",
    "description": "Log-sigmoid activation function."
  },
  "604": {
    "name": "log_softmax",
    "module": "jax.nn",
    "fullName": "jax.nn.log_softmax",
    "signature": "(x: Any, axis: Union[int, Tuple[int, ...], NoneType] = -1, where: Optional[Any] = None, initial: Optional[Any] = None) -> Any",
    "description": "Log-Softmax function."
  },
  "605": {
    "name": "logsumexp",
    "module": "jax.nn",
    "fullName": "jax.nn.logsumexp",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], axis: Optional[int] = None, b: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, NoneType] = None, keepdims: bool = False, return_sign: bool = False) -> Union[jax.Array, Tuple[jax.Array, jax.Array]]",
    "description": "Compute the log of the sum of exponentials of input elements."
  },
  "606": {
    "name": "normalize",
    "module": "jax.nn",
    "fullName": "jax.nn.normalize",
    "signature": "(x: Any, axis: Union[int, Tuple[int, ...], NoneType] = -1, mean: Optional[Any] = None, variance: Optional[Any] = None, epsilon: Any = 1e-05, where: Optional[Any] = None) -> Any",
    "description": "Normalizes an array by subtracting ``mean`` and dividing by :math:`\\sqrt{\\mathrm{variance}}`."
  },
  "607": {
    "name": "one_hot",
    "module": "jax.nn",
    "fullName": "jax.nn.one_hot",
    "signature": "(x: Any, num_classes: int, *, dtype: Any = <class 'jax.numpy.float64'>, axis: Union[int, Hashable] = -1) -> Any",
    "description": "One-hot encodes the given indices."
  },
  "608": {
    "name": "selu",
    "module": "jax.nn",
    "fullName": "jax.nn.selu",
    "signature": "(x: Any) -> Any",
    "description": "Scaled exponential linear unit activation."
  },
  "609": {
    "name": "sigmoid",
    "module": "jax.nn",
    "fullName": "jax.nn.sigmoid",
    "signature": "(x: Any) -> Any",
    "description": "Sigmoid activation function."
  },
  "610": {
    "name": "silu",
    "module": "jax.nn",
    "fullName": "jax.nn.silu",
    "signature": "(x: Any) -> Any",
    "description": "SiLU activation function."
  },
  "611": {
    "name": "soft_sign",
    "module": "jax.nn",
    "fullName": "jax.nn.soft_sign",
    "signature": "(x: Any) -> Any",
    "description": "Soft-sign activation function."
  },
  "612": {
    "name": "softmax",
    "module": "jax.nn",
    "fullName": "jax.nn.softmax",
    "signature": "(x: Any, axis: Union[int, Tuple[int, ...], NoneType] = -1, where: Optional[Any] = None, initial: Optional[Any] = None) -> Any",
    "description": "Softmax function."
  },
  "613": {
    "name": "softplus",
    "module": "jax.nn",
    "fullName": "jax.nn.softplus",
    "signature": "(x: Any) -> Any",
    "description": "Softplus activation function."
  },
  "614": {
    "name": "standardize",
    "module": "jax.nn",
    "fullName": "jax.nn.standardize",
    "signature": "(x: Any, axis: Union[int, Tuple[int, ...], NoneType] = -1, mean: Optional[Any] = None, variance: Optional[Any] = None, epsilon: Any = 1e-05, where: Optional[Any] = None) -> Any",
    "description": "Normalizes an array by subtracting ``mean`` and dividing by :math:`\\sqrt{\\mathrm{variance}}`."
  },
  "615": {
    "name": "swish",
    "module": "jax.nn",
    "fullName": "jax.nn.swish",
    "signature": "(x: Any) -> Any",
    "description": "SiLU activation function."
  },
  "616": {
    "name": "tanh",
    "module": "jax.nn",
    "fullName": "jax.nn.tanh",
    "signature": "(x, /)",
    "description": "Compute hyperbolic tangent element-wise."
  },
  "617": {
    "name": "constant",
    "module": "jax.nn.initializers",
    "fullName": "jax.nn.initializers.constant",
    "signature": "(value: Any, dtype: Any = <class 'jax.numpy.float64'>) -> jax.nn.initializers.Initializer",
    "description": "Builds an initializer that returns arrays full of a constant ``value``."
  },
  "618": {
    "name": "delta_orthogonal",
    "module": "jax.nn.initializers",
    "fullName": "jax.nn.initializers.delta_orthogonal",
    "signature": "(scale: Any = 1.0, column_axis: int = -1, dtype: Any = <class 'jax.numpy.float64'>) -> jax.nn.initializers.Initializer",
    "description": "Builds an initializer for delta orthogonal kernels."
  },
  "619": {
    "name": "glorot_normal",
    "module": "jax.nn.initializers",
    "fullName": "jax.nn.initializers.glorot_normal",
    "signature": "(in_axis: Union[int, Sequence[int]] = -2, out_axis: Union[int, Sequence[int]] = -1, batch_axis: Sequence[int] = (), dtype: Any = <class 'jax.numpy.float64'>) -> jax.nn.initializers.Initializer",
    "description": "Builds a Glorot normal initializer (aka Xavier normal initializer)."
  },
  "620": {
    "name": "glorot_uniform",
    "module": "jax.nn.initializers",
    "fullName": "jax.nn.initializers.glorot_uniform",
    "signature": "(in_axis: Union[int, Sequence[int]] = -2, out_axis: Union[int, Sequence[int]] = -1, batch_axis: Sequence[int] = (), dtype: Any = <class 'jax.numpy.float64'>) -> jax.nn.initializers.Initializer",
    "description": "Builds a Glorot uniform initializer (aka Xavier uniform initializer)."
  },
  "621": {
    "name": "he_normal",
    "module": "jax.nn.initializers",
    "fullName": "jax.nn.initializers.he_normal",
    "signature": "(in_axis: Union[int, Sequence[int]] = -2, out_axis: Union[int, Sequence[int]] = -1, batch_axis: Sequence[int] = (), dtype: Any = <class 'jax.numpy.float64'>) -> jax.nn.initializers.Initializer",
    "description": "Builds a He normal initializer (aka Kaiming normal initializer)."
  },
  "622": {
    "name": "he_uniform",
    "module": "jax.nn.initializers",
    "fullName": "jax.nn.initializers.he_uniform",
    "signature": "(in_axis: Union[int, Sequence[int]] = -2, out_axis: Union[int, Sequence[int]] = -1, batch_axis: Sequence[int] = (), dtype: Any = <class 'jax.numpy.float64'>) -> jax.nn.initializers.Initializer",
    "description": "Builds a He uniform initializer (aka Kaiming uniform initializer)."
  },
  "623": {
    "name": "kaiming_normal",
    "module": "jax.nn.initializers",
    "fullName": "jax.nn.initializers.kaiming_normal",
    "signature": "(in_axis: Union[int, Sequence[int]] = -2, out_axis: Union[int, Sequence[int]] = -1, batch_axis: Sequence[int] = (), dtype: Any = <class 'jax.numpy.float64'>) -> jax.nn.initializers.Initializer",
    "description": "Builds a He normal initializer (aka Kaiming normal initializer)."
  },
  "624": {
    "name": "kaiming_uniform",
    "module": "jax.nn.initializers",
    "fullName": "jax.nn.initializers.kaiming_uniform",
    "signature": "(in_axis: Union[int, Sequence[int]] = -2, out_axis: Union[int, Sequence[int]] = -1, batch_axis: Sequence[int] = (), dtype: Any = <class 'jax.numpy.float64'>) -> jax.nn.initializers.Initializer",
    "description": "Builds a He uniform initializer (aka Kaiming uniform initializer)."
  },
  "625": {
    "name": "lecun_normal",
    "module": "jax.nn.initializers",
    "fullName": "jax.nn.initializers.lecun_normal",
    "signature": "(in_axis: Union[int, Sequence[int]] = -2, out_axis: Union[int, Sequence[int]] = -1, batch_axis: Sequence[int] = (), dtype: Any = <class 'jax.numpy.float64'>) -> jax.nn.initializers.Initializer",
    "description": "Builds a Lecun normal initializer."
  },
  "626": {
    "name": "lecun_uniform",
    "module": "jax.nn.initializers",
    "fullName": "jax.nn.initializers.lecun_uniform",
    "signature": "(in_axis: Union[int, Sequence[int]] = -2, out_axis: Union[int, Sequence[int]] = -1, batch_axis: Sequence[int] = (), dtype: Any = <class 'jax.numpy.float64'>) -> jax.nn.initializers.Initializer",
    "description": "Builds a Lecun uniform initializer."
  },
  "627": {
    "name": "normal",
    "module": "jax.nn.initializers",
    "fullName": "jax.nn.initializers.normal",
    "signature": "(stddev: Any = 0.01, dtype: Any = <class 'jax.numpy.float64'>) -> jax.nn.initializers.Initializer",
    "description": "Builds an initializer that returns real normally-distributed random arrays."
  },
  "628": {
    "name": "ones",
    "module": "jax.nn.initializers",
    "fullName": "jax.nn.initializers.ones",
    "signature": "(key: jax._src.prng.PRNGKeyArray, shape: Sequence[Union[int, Any]], dtype: Any = <class 'jax.numpy.float64'>) -> Any",
    "description": "An initializer that returns a constant array full of ones."
  },
  "629": {
    "name": "orthogonal",
    "module": "jax.nn.initializers",
    "fullName": "jax.nn.initializers.orthogonal",
    "signature": "(scale: Any = 1.0, column_axis: int = -1, dtype: Any = <class 'jax.numpy.float64'>) -> jax.nn.initializers.Initializer",
    "description": "Builds an initializer that returns uniformly distributed orthogonal matrices."
  },
  "630": {
    "name": "uniform",
    "module": "jax.nn.initializers",
    "fullName": "jax.nn.initializers.uniform",
    "signature": "(scale: Any = 0.01, dtype: Any = <class 'jax.numpy.float64'>) -> jax.nn.initializers.Initializer",
    "description": "Builds an initializer that returns real uniformly-distributed random arrays."
  },
  "631": {
    "name": "variance_scaling",
    "module": "jax.nn.initializers",
    "fullName": "jax.nn.initializers.variance_scaling",
    "signature": "(scale: Any, mode: Union[Literal['fan_in'], Literal['fan_out'], Literal['fan_avg']], distribution: Union[Literal['truncated_normal'], Literal['normal'], Literal['uniform']], in_axis: Union[int, Sequence[int]] = -2, out_axis: Union[int, Sequence[int]] = -1, batch_axis: Sequence[int] = (), dtype: Any = <class 'jax.numpy.float64'>) -> jax.nn.initializers.Initializer",
    "description": "Initializer that adapts its scale to the shape of the weights tensor."
  },
  "632": {
    "name": "xavier_normal",
    "module": "jax.nn.initializers",
    "fullName": "jax.nn.initializers.xavier_normal",
    "signature": "(in_axis: Union[int, Sequence[int]] = -2, out_axis: Union[int, Sequence[int]] = -1, batch_axis: Sequence[int] = (), dtype: Any = <class 'jax.numpy.float64'>) -> jax.nn.initializers.Initializer",
    "description": "Builds a Glorot normal initializer (aka Xavier normal initializer)."
  },
  "633": {
    "name": "xavier_uniform",
    "module": "jax.nn.initializers",
    "fullName": "jax.nn.initializers.xavier_uniform",
    "signature": "(in_axis: Union[int, Sequence[int]] = -2, out_axis: Union[int, Sequence[int]] = -1, batch_axis: Sequence[int] = (), dtype: Any = <class 'jax.numpy.float64'>) -> jax.nn.initializers.Initializer",
    "description": "Builds a Glorot uniform initializer (aka Xavier uniform initializer)."
  },
  "634": {
    "name": "zeros",
    "module": "jax.nn.initializers",
    "fullName": "jax.nn.initializers.zeros",
    "signature": "(key: jax._src.prng.PRNGKeyArray, shape: Sequence[Union[int, Any]], dtype: Any = <class 'jax.numpy.float64'>) -> Any",
    "description": "An initializer that returns a constant array full of zeros."
  },
  "635": {
    "name": "record_event",
    "module": "jax.monitoring",
    "fullName": "jax.monitoring.record_event",
    "signature": "(event: str) -> None",
    "description": "Record an event."
  },
  "636": {
    "name": "record_event_duration_secs",
    "module": "jax.monitoring",
    "fullName": "jax.monitoring.record_event_duration_secs",
    "signature": "(event: str, duration: float) -> None",
    "description": "Record an event duration in seconds (float)."
  },
  "637": {
    "name": "register_event_duration_secs_listener",
    "module": "jax.monitoring",
    "fullName": "jax.monitoring.register_event_duration_secs_listener",
    "signature": "(callback: Callable[[str, float], NoneType]) -> None",
    "description": "Register a callback to be invoked during record_event_duration_secs()."
  },
  "638": {
    "name": "register_event_listener",
    "module": "jax.monitoring",
    "fullName": "jax.monitoring.register_event_listener",
    "signature": "(callback: Callable[[str], NoneType]) -> None",
    "description": "Register a callback to be invoked during record_event()."
  },
  "639": {
    "name": "cache",
    "module": "jax.linear_util",
    "fullName": "jax.linear_util.cache",
    "signature": "(call: 'Callable')",
    "description": "Memoization decorator for functions taking a WrappedFun as first argument."
  },
  "640": {
    "name": "merge_linear_aux",
    "module": "jax.linear_util",
    "fullName": "jax.linear_util.merge_linear_aux",
    "signature": "(aux1, aux2)",
    "description": "No description available."
  },
  "641": {
    "name": "wrap_init",
    "module": "jax.linear_util",
    "fullName": "jax.linear_util.wrap_init",
    "signature": "(f, params=None) -> 'WrappedFun'",
    "description": "Wraps function `f` as a `WrappedFun`, suitable for transformation."
  },
  "642": {
    "name": "CurrentSourceInfoMetadata",
    "module": "jax.lib.xla_client",
    "fullName": "jax.lib.xla_client.CurrentSourceInfoMetadata",
    "signature": "(op_type=None, op_name=None, skip_frames=1)",
    "description": "Helper for use in source mapping that returns an OpMetadata object."
  },
  "643": {
    "name": "LoadedExecutable_execute",
    "module": "jax.lib.xla_client",
    "fullName": "jax.lib.xla_client.LoadedExecutable_execute",
    "signature": "(self, arguments, device=None)",
    "description": "No description available."
  },
  "644": {
    "name": "LoadedExecutable_execute_with_token",
    "module": "jax.lib.xla_client",
    "fullName": "jax.lib.xla_client.LoadedExecutable_execute_with_token",
    "signature": "(self, arguments, device=None)",
    "description": "No description available."
  },
  "645": {
    "name": "dtype_to_etype",
    "module": "jax.lib.xla_client",
    "fullName": "jax.lib.xla_client.dtype_to_etype",
    "signature": "(dtype)",
    "description": "Convenience function for reading DTYPE_TO_XLA_ELEMENT_TYPE."
  },
  "646": {
    "name": "execute_with_python_values",
    "module": "jax.lib.xla_client",
    "fullName": "jax.lib.xla_client.execute_with_python_values",
    "signature": "(executable, arguments, backend)",
    "description": "Execute on one replica with Python values as arguments and output."
  },
  "647": {
    "name": "execute_with_python_values_replicated",
    "module": "jax.lib.xla_client",
    "fullName": "jax.lib.xla_client.execute_with_python_values_replicated",
    "signature": "(executable, arguments, backend)",
    "description": "Execute on many replicas with Python values as arguments and output."
  },
  "648": {
    "name": "heap_profile",
    "module": "jax.lib.xla_client",
    "fullName": "jax.lib.xla_client.heap_profile",
    "signature": "(client: jaxlib.xla_extension.Client) -> bytes",
    "description": "Returns a gzipped pprof protocol buffer containing a heap profile."
  },
  "649": {
    "name": "load_pjrt_plugin_dynamically",
    "module": "jax.lib.xla_client",
    "fullName": "jax.lib.xla_client.load_pjrt_plugin_dynamically",
    "signature": "(plugin_name: str, library_path: str) -> None",
    "description": "No description available."
  },
  "650": {
    "name": "make_c_api_client",
    "module": "jax.lib.xla_client",
    "fullName": "jax.lib.xla_client.make_c_api_client",
    "signature": "(plugin_name: str, options: Optional[Mapping[str, Union[str, int, List[int], float]]] = None)",
    "description": "Creates a PJRT C API client for a PJRT plugin."
  },
  "651": {
    "name": "make_convolution_dimension_numbers",
    "module": "jax.lib.xla_client",
    "fullName": "jax.lib.xla_client.make_convolution_dimension_numbers",
    "signature": "(dimension_numbers: Union[NoneType, jaxlib.xla_client.ConvolutionDimensionNumbers, Tuple[str, str, str]], num_spatial_dimensions: int) -> jaxlib.xla_client.ConvolutionDimensionNumbers",
    "description": "Builds a ConvolutionDimensionNumbers object from a specification."
  },
  "652": {
    "name": "make_cpu_client",
    "module": "jax.lib.xla_client",
    "fullName": "jax.lib.xla_client.make_cpu_client",
    "signature": "(*, use_tfrt: bool = True) -> Ellipsis",
    "description": "No description available."
  },
  "653": {
    "name": "make_dot_dimension_numbers",
    "module": "jax.lib.xla_client",
    "fullName": "jax.lib.xla_client.make_dot_dimension_numbers",
    "signature": "(dimension_numbers: Union[jaxlib.xla_client.DotDimensionNumbers, Tuple[Tuple[List[int], List[int]], Tuple[List[int], List[int]]]]) -> jaxlib.xla_client.DotDimensionNumbers",
    "description": "Builds a DotDimensionNumbers object from a specification."
  },
  "654": {
    "name": "make_gpu_client",
    "module": "jax.lib.xla_client",
    "fullName": "jax.lib.xla_client.make_gpu_client",
    "signature": "(distributed_client=None, node_id=0, num_nodes=1, platform_name=None, allowed_devices=None)",
    "description": "Returns a GPU client. BFC allocator is used by default."
  },
  "655": {
    "name": "make_interpreter_client",
    "module": "jax.lib.xla_client",
    "fullName": "jax.lib.xla_client.make_interpreter_client",
    "signature": "()",
    "description": "No description available."
  },
  "656": {
    "name": "make_padding_config",
    "module": "jax.lib.xla_client",
    "fullName": "jax.lib.xla_client.make_padding_config",
    "signature": "(padding_config: Union[jaxlib.xla_client.PaddingConfig, Sequence[Tuple[int, int, int]]]) -> jaxlib.xla_client.PaddingConfig",
    "description": "Create PaddingConfig proto from list of triples of integers."
  },
  "657": {
    "name": "make_replica_groups",
    "module": "jax.lib.xla_client",
    "fullName": "jax.lib.xla_client.make_replica_groups",
    "signature": "(replica_groups)",
    "description": "No description available."
  },
  "658": {
    "name": "make_tfrt_tpu_c_api_client",
    "module": "jax.lib.xla_client",
    "fullName": "jax.lib.xla_client.make_tfrt_tpu_c_api_client",
    "signature": "(options: Optional[Mapping[str, Union[str, int, List[int], float]]] = None)",
    "description": "No description available."
  },
  "659": {
    "name": "make_tfrt_tpu_c_api_device_topology",
    "module": "jax.lib.xla_client",
    "fullName": "jax.lib.xla_client.make_tfrt_tpu_c_api_device_topology",
    "signature": "(topology_name: str = '', **kwargs) -> jaxlib.xla_extension.DeviceTopology",
    "description": "Creates a PJRT C API TopologyDescription."
  },
  "660": {
    "name": "make_tpu_client",
    "module": "jax.lib.xla_client",
    "fullName": "jax.lib.xla_client.make_tpu_client",
    "signature": "(use_pjrt_c_api: bool = False)",
    "description": "Returns a TPU client. Defaults to allowing 32 in-flight computations."
  },
  "661": {
    "name": "pjrt_plugin_loaded",
    "module": "jax.lib.xla_client",
    "fullName": "jax.lib.xla_client.pjrt_plugin_loaded",
    "signature": "(plugin_name: str) -> bool",
    "description": "No description available."
  },
  "662": {
    "name": "register_cpu_custom_call_target",
    "module": "jax.lib.xla_client",
    "fullName": "jax.lib.xla_client.register_cpu_custom_call_target",
    "signature": "(name: str, fn: Any, platform: str = 'cpu') -> None",
    "description": "Registers a custom call target."
  },
  "663": {
    "name": "register_custom_call_target",
    "module": "jax.lib.xla_client",
    "fullName": "jax.lib.xla_client.register_custom_call_target",
    "signature": "(name: str, fn: Any, platform: str = 'cpu') -> None",
    "description": "Registers a custom call target."
  },
  "664": {
    "name": "shape_from_pyval",
    "module": "jax.lib.xla_client",
    "fullName": "jax.lib.xla_client.shape_from_pyval",
    "signature": "(pyval)",
    "description": "Returns a Shape that describes a tuple-tree of Numpy arrays."
  },
  "665": {
    "name": "tracebacks",
    "module": "jax.lib.xla_client",
    "fullName": "jax.lib.xla_client.tracebacks",
    "signature": "(enabled=True)",
    "description": "Context manager that enables or disables traceback collection."
  },
  "666": {
    "name": "window_padding_type_to_pad_values",
    "module": "jax.lib.xla_client",
    "fullName": "jax.lib.xla_client.window_padding_type_to_pad_values",
    "signature": "(padding_type, lhs_dims, rhs_dims, window_strides)",
    "description": "Maps PaddingType or string to pad values (list of pairs of ints)."
  },
  "667": {
    "name": "add_dll_directory",
    "module": "jax.lib.xla_client.os",
    "fullName": "jax.lib.xla_client.os.add_dll_directory",
    "signature": "(path)",
    "description": "Add a path to the DLL search path."
  },
  "668": {
    "name": "execl",
    "module": "jax.lib.xla_client.os",
    "fullName": "jax.lib.xla_client.os.execl",
    "signature": "(file, *args)",
    "description": "execl(file, *args)"
  },
  "669": {
    "name": "execle",
    "module": "jax.lib.xla_client.os",
    "fullName": "jax.lib.xla_client.os.execle",
    "signature": "(file, *args)",
    "description": "execle(file, *args, env)"
  },
  "670": {
    "name": "execlp",
    "module": "jax.lib.xla_client.os",
    "fullName": "jax.lib.xla_client.os.execlp",
    "signature": "(file, *args)",
    "description": "execlp(file, *args)"
  },
  "671": {
    "name": "execlpe",
    "module": "jax.lib.xla_client.os",
    "fullName": "jax.lib.xla_client.os.execlpe",
    "signature": "(file, *args)",
    "description": "execlpe(file, *args, env)"
  },
  "672": {
    "name": "execvp",
    "module": "jax.lib.xla_client.os",
    "fullName": "jax.lib.xla_client.os.execvp",
    "signature": "(file, args)",
    "description": "execvp(file, args)"
  },
  "673": {
    "name": "execvpe",
    "module": "jax.lib.xla_client.os",
    "fullName": "jax.lib.xla_client.os.execvpe",
    "signature": "(file, args, env)",
    "description": "execvpe(file, args, env)"
  },
  "674": {
    "name": "fdopen",
    "module": "jax.lib.xla_client.os",
    "fullName": "jax.lib.xla_client.os.fdopen",
    "signature": "(fd, *args, **kwargs)",
    "description": "No description available."
  },
  "675": {
    "name": "fsdecode",
    "module": "jax.lib.xla_client.os",
    "fullName": "jax.lib.xla_client.os.fsdecode",
    "signature": "(filename)",
    "description": "Decode filename (an os.PathLike, bytes, or str) from the filesystem"
  },
  "676": {
    "name": "fsencode",
    "module": "jax.lib.xla_client.os",
    "fullName": "jax.lib.xla_client.os.fsencode",
    "signature": "(filename)",
    "description": "Encode filename (an os.PathLike, bytes, or str) to the filesystem"
  },
  "677": {
    "name": "get_exec_path",
    "module": "jax.lib.xla_client.os",
    "fullName": "jax.lib.xla_client.os.get_exec_path",
    "signature": "(env=None)",
    "description": "Returns the sequence of directories that will be searched for the"
  },
  "678": {
    "name": "getenv",
    "module": "jax.lib.xla_client.os",
    "fullName": "jax.lib.xla_client.os.getenv",
    "signature": "(key, default=None)",
    "description": "Get an environment variable, return None if it doesn't exist."
  },
  "679": {
    "name": "makedirs",
    "module": "jax.lib.xla_client.os",
    "fullName": "jax.lib.xla_client.os.makedirs",
    "signature": "(name, mode=511, exist_ok=False)",
    "description": "makedirs(name [, mode=0o777][, exist_ok=False])"
  },
  "680": {
    "name": "popen",
    "module": "jax.lib.xla_client.os",
    "fullName": "jax.lib.xla_client.os.popen",
    "signature": "(cmd, mode='r', buffering=-1)",
    "description": "No description available."
  },
  "681": {
    "name": "removedirs",
    "module": "jax.lib.xla_client.os",
    "fullName": "jax.lib.xla_client.os.removedirs",
    "signature": "(name)",
    "description": "removedirs(name)"
  },
  "682": {
    "name": "renames",
    "module": "jax.lib.xla_client.os",
    "fullName": "jax.lib.xla_client.os.renames",
    "signature": "(old, new)",
    "description": "renames(old, new)"
  },
  "683": {
    "name": "spawnl",
    "module": "jax.lib.xla_client.os",
    "fullName": "jax.lib.xla_client.os.spawnl",
    "signature": "(mode, file, *args)",
    "description": "spawnl(mode, file, *args) -> integer"
  },
  "684": {
    "name": "spawnle",
    "module": "jax.lib.xla_client.os",
    "fullName": "jax.lib.xla_client.os.spawnle",
    "signature": "(mode, file, *args)",
    "description": "spawnle(mode, file, *args, env) -> integer"
  },
  "685": {
    "name": "walk",
    "module": "jax.lib.xla_client.os",
    "fullName": "jax.lib.xla_client.os.walk",
    "signature": "(top, topdown=True, onerror=None, followlinks=False)",
    "description": "Directory tree generator."
  },
  "686": {
    "name": "abspath",
    "module": "jax.lib.xla_client.os.path",
    "fullName": "jax.lib.xla_client.os.path.abspath",
    "signature": "(path)",
    "description": "Return the absolute version of a path."
  },
  "687": {
    "name": "basename",
    "module": "jax.lib.xla_client.os.path",
    "fullName": "jax.lib.xla_client.os.path.basename",
    "signature": "(p)",
    "description": "Returns the final component of a pathname"
  },
  "688": {
    "name": "commonpath",
    "module": "jax.lib.xla_client.os.path",
    "fullName": "jax.lib.xla_client.os.path.commonpath",
    "signature": "(paths)",
    "description": "Given a sequence of path names, returns the longest common sub-path."
  },
  "689": {
    "name": "commonprefix",
    "module": "jax.lib.xla_client.os.path",
    "fullName": "jax.lib.xla_client.os.path.commonprefix",
    "signature": "(m)",
    "description": "Given a list of pathnames, returns the longest common leading component"
  },
  "690": {
    "name": "dirname",
    "module": "jax.lib.xla_client.os.path",
    "fullName": "jax.lib.xla_client.os.path.dirname",
    "signature": "(p)",
    "description": "Returns the directory component of a pathname"
  },
  "691": {
    "name": "exists",
    "module": "jax.lib.xla_client.os.path",
    "fullName": "jax.lib.xla_client.os.path.exists",
    "signature": "(path)",
    "description": "Test whether a path exists.  Returns False for broken symbolic links"
  },
  "692": {
    "name": "expanduser",
    "module": "jax.lib.xla_client.os.path",
    "fullName": "jax.lib.xla_client.os.path.expanduser",
    "signature": "(path)",
    "description": "Expand ~ and ~user constructs."
  },
  "693": {
    "name": "expandvars",
    "module": "jax.lib.xla_client.os.path",
    "fullName": "jax.lib.xla_client.os.path.expandvars",
    "signature": "(path)",
    "description": "Expand shell variables of the forms $var, ${var} and %var%."
  },
  "694": {
    "name": "getatime",
    "module": "jax.lib.xla_client.os.path",
    "fullName": "jax.lib.xla_client.os.path.getatime",
    "signature": "(filename)",
    "description": "Return the last access time of a file, reported by os.stat()."
  },
  "695": {
    "name": "getctime",
    "module": "jax.lib.xla_client.os.path",
    "fullName": "jax.lib.xla_client.os.path.getctime",
    "signature": "(filename)",
    "description": "Return the metadata change time of a file, reported by os.stat()."
  },
  "696": {
    "name": "getmtime",
    "module": "jax.lib.xla_client.os.path",
    "fullName": "jax.lib.xla_client.os.path.getmtime",
    "signature": "(filename)",
    "description": "Return the last modification time of a file, reported by os.stat()."
  },
  "697": {
    "name": "getsize",
    "module": "jax.lib.xla_client.os.path",
    "fullName": "jax.lib.xla_client.os.path.getsize",
    "signature": "(filename)",
    "description": "Return the size of a file, reported by os.stat()."
  },
  "698": {
    "name": "isabs",
    "module": "jax.lib.xla_client.os.path",
    "fullName": "jax.lib.xla_client.os.path.isabs",
    "signature": "(s)",
    "description": "Test whether a path is absolute"
  },
  "699": {
    "name": "isdir",
    "module": "jax.lib.xla_client.os.path",
    "fullName": "jax.lib.xla_client.os.path.isdir",
    "signature": "(s)",
    "description": "Return true if the pathname refers to an existing directory."
  },
  "700": {
    "name": "isfile",
    "module": "jax.lib.xla_client.os.path",
    "fullName": "jax.lib.xla_client.os.path.isfile",
    "signature": "(path)",
    "description": "Test whether a path is a regular file"
  },
  "701": {
    "name": "islink",
    "module": "jax.lib.xla_client.os.path",
    "fullName": "jax.lib.xla_client.os.path.islink",
    "signature": "(path)",
    "description": "Test whether a path is a symbolic link."
  },
  "702": {
    "name": "ismount",
    "module": "jax.lib.xla_client.os.path",
    "fullName": "jax.lib.xla_client.os.path.ismount",
    "signature": "(path)",
    "description": "Test whether a path is a mount point (a drive root, the root of a"
  },
  "703": {
    "name": "join",
    "module": "jax.lib.xla_client.os.path",
    "fullName": "jax.lib.xla_client.os.path.join",
    "signature": "(path, *paths)",
    "description": "No description available."
  },
  "704": {
    "name": "lexists",
    "module": "jax.lib.xla_client.os.path",
    "fullName": "jax.lib.xla_client.os.path.lexists",
    "signature": "(path)",
    "description": "Test whether a path exists.  Returns True for broken symbolic links"
  },
  "705": {
    "name": "normcase",
    "module": "jax.lib.xla_client.os.path",
    "fullName": "jax.lib.xla_client.os.path.normcase",
    "signature": "(s)",
    "description": "Normalize case of pathname."
  },
  "706": {
    "name": "normpath",
    "module": "jax.lib.xla_client.os.path",
    "fullName": "jax.lib.xla_client.os.path.normpath",
    "signature": "(path)",
    "description": "Normalize path, eliminating double slashes, etc."
  },
  "707": {
    "name": "realpath",
    "module": "jax.lib.xla_client.os.path",
    "fullName": "jax.lib.xla_client.os.path.realpath",
    "signature": "(path)",
    "description": "No description available."
  },
  "708": {
    "name": "relpath",
    "module": "jax.lib.xla_client.os.path",
    "fullName": "jax.lib.xla_client.os.path.relpath",
    "signature": "(path, start=None)",
    "description": "Return a relative version of a path"
  },
  "709": {
    "name": "samefile",
    "module": "jax.lib.xla_client.os.path",
    "fullName": "jax.lib.xla_client.os.path.samefile",
    "signature": "(f1, f2)",
    "description": "Test whether two pathnames reference the same actual file or directory"
  },
  "710": {
    "name": "sameopenfile",
    "module": "jax.lib.xla_client.os.path",
    "fullName": "jax.lib.xla_client.os.path.sameopenfile",
    "signature": "(fp1, fp2)",
    "description": "Test whether two open file objects reference the same file"
  },
  "711": {
    "name": "samestat",
    "module": "jax.lib.xla_client.os.path",
    "fullName": "jax.lib.xla_client.os.path.samestat",
    "signature": "(s1, s2)",
    "description": "Test whether two stat buffers reference the same file"
  },
  "712": {
    "name": "split",
    "module": "jax.lib.xla_client.os.path",
    "fullName": "jax.lib.xla_client.os.path.split",
    "signature": "(p)",
    "description": "Split a pathname."
  },
  "713": {
    "name": "splitdrive",
    "module": "jax.lib.xla_client.os.path",
    "fullName": "jax.lib.xla_client.os.path.splitdrive",
    "signature": "(p)",
    "description": "Split a pathname into drive/UNC sharepoint and relative path specifiers."
  },
  "714": {
    "name": "splitext",
    "module": "jax.lib.xla_client.os.path",
    "fullName": "jax.lib.xla_client.os.path.splitext",
    "signature": "(p)",
    "description": "Split the extension from a pathname."
  },
  "715": {
    "name": "commonprefix",
    "module": "jax.lib.xla_client.os.path.genericpath",
    "fullName": "jax.lib.xla_client.os.path.genericpath.commonprefix",
    "signature": "(m)",
    "description": "Given a list of pathnames, returns the longest common leading component"
  },
  "716": {
    "name": "exists",
    "module": "jax.lib.xla_client.os.path.genericpath",
    "fullName": "jax.lib.xla_client.os.path.genericpath.exists",
    "signature": "(path)",
    "description": "Test whether a path exists.  Returns False for broken symbolic links"
  },
  "717": {
    "name": "getatime",
    "module": "jax.lib.xla_client.os.path.genericpath",
    "fullName": "jax.lib.xla_client.os.path.genericpath.getatime",
    "signature": "(filename)",
    "description": "Return the last access time of a file, reported by os.stat()."
  },
  "718": {
    "name": "getctime",
    "module": "jax.lib.xla_client.os.path.genericpath",
    "fullName": "jax.lib.xla_client.os.path.genericpath.getctime",
    "signature": "(filename)",
    "description": "Return the metadata change time of a file, reported by os.stat()."
  },
  "719": {
    "name": "getmtime",
    "module": "jax.lib.xla_client.os.path.genericpath",
    "fullName": "jax.lib.xla_client.os.path.genericpath.getmtime",
    "signature": "(filename)",
    "description": "Return the last modification time of a file, reported by os.stat()."
  },
  "720": {
    "name": "getsize",
    "module": "jax.lib.xla_client.os.path.genericpath",
    "fullName": "jax.lib.xla_client.os.path.genericpath.getsize",
    "signature": "(filename)",
    "description": "Return the size of a file, reported by os.stat()."
  },
  "721": {
    "name": "isdir",
    "module": "jax.lib.xla_client.os.path.genericpath",
    "fullName": "jax.lib.xla_client.os.path.genericpath.isdir",
    "signature": "(s)",
    "description": "Return true if the pathname refers to an existing directory."
  },
  "722": {
    "name": "isfile",
    "module": "jax.lib.xla_client.os.path.genericpath",
    "fullName": "jax.lib.xla_client.os.path.genericpath.isfile",
    "signature": "(path)",
    "description": "Test whether a path is a regular file"
  },
  "723": {
    "name": "samefile",
    "module": "jax.lib.xla_client.os.path.genericpath",
    "fullName": "jax.lib.xla_client.os.path.genericpath.samefile",
    "signature": "(f1, f2)",
    "description": "Test whether two pathnames reference the same actual file or directory"
  },
  "724": {
    "name": "sameopenfile",
    "module": "jax.lib.xla_client.os.path.genericpath",
    "fullName": "jax.lib.xla_client.os.path.genericpath.sameopenfile",
    "signature": "(fp1, fp2)",
    "description": "Test whether two open file objects reference the same file"
  },
  "725": {
    "name": "samestat",
    "module": "jax.lib.xla_client.os.path.genericpath",
    "fullName": "jax.lib.xla_client.os.path.genericpath.samestat",
    "signature": "(s1, s2)",
    "description": "Test whether two stat buffers reference the same file"
  },
  "726": {
    "name": "addLevelName",
    "module": "jax.lib.xla_client.logging",
    "fullName": "jax.lib.xla_client.logging.addLevelName",
    "signature": "(level, levelName)",
    "description": "Associate 'levelName' with 'level'."
  },
  "727": {
    "name": "basicConfig",
    "module": "jax.lib.xla_client.logging",
    "fullName": "jax.lib.xla_client.logging.basicConfig",
    "signature": "(**kwargs)",
    "description": "Do basic configuration for the logging system."
  },
  "728": {
    "name": "captureWarnings",
    "module": "jax.lib.xla_client.logging",
    "fullName": "jax.lib.xla_client.logging.captureWarnings",
    "signature": "(capture)",
    "description": "If capture is true, redirect all warnings to the logging package."
  },
  "729": {
    "name": "critical",
    "module": "jax.lib.xla_client.logging",
    "fullName": "jax.lib.xla_client.logging.critical",
    "signature": "(msg, *args, **kwargs)",
    "description": "Log a message with severity 'CRITICAL' on the root logger. If the logger"
  },
  "730": {
    "name": "currentframe",
    "module": "jax.lib.xla_client.logging",
    "fullName": "jax.lib.xla_client.logging.currentframe",
    "signature": "()",
    "description": "No description available."
  },
  "731": {
    "name": "debug",
    "module": "jax.lib.xla_client.logging",
    "fullName": "jax.lib.xla_client.logging.debug",
    "signature": "(msg, *args, **kwargs)",
    "description": "Log a message with severity 'DEBUG' on the root logger. If the logger has"
  },
  "732": {
    "name": "disable",
    "module": "jax.lib.xla_client.logging",
    "fullName": "jax.lib.xla_client.logging.disable",
    "signature": "(level=50)",
    "description": "Disable all logging calls of severity 'level' and below."
  },
  "733": {
    "name": "error",
    "module": "jax.lib.xla_client.logging",
    "fullName": "jax.lib.xla_client.logging.error",
    "signature": "(msg, *args, **kwargs)",
    "description": "Log a message with severity 'ERROR' on the root logger. If the logger has"
  },
  "734": {
    "name": "exception",
    "module": "jax.lib.xla_client.logging",
    "fullName": "jax.lib.xla_client.logging.exception",
    "signature": "(msg, *args, exc_info=True, **kwargs)",
    "description": "Log a message with severity 'ERROR' on the root logger, with exception"
  },
  "735": {
    "name": "fatal",
    "module": "jax.lib.xla_client.logging",
    "fullName": "jax.lib.xla_client.logging.fatal",
    "signature": "(msg, *args, **kwargs)",
    "description": "Log a message with severity 'CRITICAL' on the root logger. If the logger"
  },
  "736": {
    "name": "getLevelName",
    "module": "jax.lib.xla_client.logging",
    "fullName": "jax.lib.xla_client.logging.getLevelName",
    "signature": "(level)",
    "description": "Return the textual or numeric representation of logging level 'level'."
  },
  "737": {
    "name": "getLogRecordFactory",
    "module": "jax.lib.xla_client.logging",
    "fullName": "jax.lib.xla_client.logging.getLogRecordFactory",
    "signature": "()",
    "description": "Return the factory to be used when instantiating a log record."
  },
  "738": {
    "name": "getLogger",
    "module": "jax.lib.xla_client.logging",
    "fullName": "jax.lib.xla_client.logging.getLogger",
    "signature": "(name=None)",
    "description": "Return a logger with the specified name, creating it if necessary."
  },
  "739": {
    "name": "getLoggerClass",
    "module": "jax.lib.xla_client.logging",
    "fullName": "jax.lib.xla_client.logging.getLoggerClass",
    "signature": "()",
    "description": "Return the class to be used when instantiating a logger."
  },
  "740": {
    "name": "info",
    "module": "jax.lib.xla_client.logging",
    "fullName": "jax.lib.xla_client.logging.info",
    "signature": "(msg, *args, **kwargs)",
    "description": "Log a message with severity 'INFO' on the root logger. If the logger has"
  },
  "741": {
    "name": "log",
    "module": "jax.lib.xla_client.logging",
    "fullName": "jax.lib.xla_client.logging.log",
    "signature": "(level, msg, *args, **kwargs)",
    "description": "Log 'msg % args' with the integer severity 'level' on the root logger. If"
  },
  "742": {
    "name": "makeLogRecord",
    "module": "jax.lib.xla_client.logging",
    "fullName": "jax.lib.xla_client.logging.makeLogRecord",
    "signature": "(dict)",
    "description": "Make a LogRecord whose attributes are defined by the specified dictionary,"
  },
  "743": {
    "name": "setLogRecordFactory",
    "module": "jax.lib.xla_client.logging",
    "fullName": "jax.lib.xla_client.logging.setLogRecordFactory",
    "signature": "(factory)",
    "description": "Set the factory to be used when instantiating a log record."
  },
  "744": {
    "name": "setLoggerClass",
    "module": "jax.lib.xla_client.logging",
    "fullName": "jax.lib.xla_client.logging.setLoggerClass",
    "signature": "(klass)",
    "description": "Set the class to be used when instantiating a logger. The class should"
  },
  "745": {
    "name": "shutdown",
    "module": "jax.lib.xla_client.logging",
    "fullName": "jax.lib.xla_client.logging.shutdown",
    "signature": "(handlerList=[<weakref at 0x0000026791E68090; to '_StderrHandler' at 0x0000026791E57C40>])",
    "description": "Perform any cleanup actions in the logging system (e.g. flushing"
  },
  "746": {
    "name": "warn",
    "module": "jax.lib.xla_client.logging",
    "fullName": "jax.lib.xla_client.logging.warn",
    "signature": "(msg, *args, **kwargs)",
    "description": "No description available."
  },
  "747": {
    "name": "warning",
    "module": "jax.lib.xla_client.logging",
    "fullName": "jax.lib.xla_client.logging.warning",
    "signature": "(msg, *args, **kwargs)",
    "description": "Log a message with severity 'WARNING' on the root logger. If the logger has"
  },
  "748": {
    "name": "clear_frames",
    "module": "jax.lib.xla_client.logging.traceback",
    "fullName": "jax.lib.xla_client.logging.traceback.clear_frames",
    "signature": "(tb)",
    "description": "Clear all references to local variables in the frames of a traceback."
  },
  "749": {
    "name": "extract_stack",
    "module": "jax.lib.xla_client.logging.traceback",
    "fullName": "jax.lib.xla_client.logging.traceback.extract_stack",
    "signature": "(f=None, limit=None)",
    "description": "Extract the raw traceback from the current stack frame."
  },
  "750": {
    "name": "extract_tb",
    "module": "jax.lib.xla_client.logging.traceback",
    "fullName": "jax.lib.xla_client.logging.traceback.extract_tb",
    "signature": "(tb, limit=None)",
    "description": "Return a StackSummary object representing a list of"
  },
  "751": {
    "name": "format_exc",
    "module": "jax.lib.xla_client.logging.traceback",
    "fullName": "jax.lib.xla_client.logging.traceback.format_exc",
    "signature": "(limit=None, chain=True)",
    "description": "Like print_exc() but return a string."
  },
  "752": {
    "name": "format_exception",
    "module": "jax.lib.xla_client.logging.traceback",
    "fullName": "jax.lib.xla_client.logging.traceback.format_exception",
    "signature": "(etype, value, tb, limit=None, chain=True)",
    "description": "Format a stack trace and the exception information."
  },
  "753": {
    "name": "format_exception_only",
    "module": "jax.lib.xla_client.logging.traceback",
    "fullName": "jax.lib.xla_client.logging.traceback.format_exception_only",
    "signature": "(etype, value)",
    "description": "Format the exception part of a traceback."
  },
  "754": {
    "name": "format_list",
    "module": "jax.lib.xla_client.logging.traceback",
    "fullName": "jax.lib.xla_client.logging.traceback.format_list",
    "signature": "(extracted_list)",
    "description": "Format a list of tuples or FrameSummary objects for printing."
  },
  "755": {
    "name": "format_stack",
    "module": "jax.lib.xla_client.logging.traceback",
    "fullName": "jax.lib.xla_client.logging.traceback.format_stack",
    "signature": "(f=None, limit=None)",
    "description": "Shorthand for 'format_list(extract_stack(f, limit))'."
  },
  "756": {
    "name": "format_tb",
    "module": "jax.lib.xla_client.logging.traceback",
    "fullName": "jax.lib.xla_client.logging.traceback.format_tb",
    "signature": "(tb, limit=None)",
    "description": "A shorthand for 'format_list(extract_tb(tb, limit))'."
  },
  "757": {
    "name": "print_exc",
    "module": "jax.lib.xla_client.logging.traceback",
    "fullName": "jax.lib.xla_client.logging.traceback.print_exc",
    "signature": "(limit=None, file=None, chain=True)",
    "description": "Shorthand for 'print_exception(*sys.exc_info(), limit, file)'."
  },
  "758": {
    "name": "print_exception",
    "module": "jax.lib.xla_client.logging.traceback",
    "fullName": "jax.lib.xla_client.logging.traceback.print_exception",
    "signature": "(etype, value, tb, limit=None, file=None, chain=True)",
    "description": "Print exception up to 'limit' stack trace entries from 'tb' to 'file'."
  },
  "759": {
    "name": "print_last",
    "module": "jax.lib.xla_client.logging.traceback",
    "fullName": "jax.lib.xla_client.logging.traceback.print_last",
    "signature": "(limit=None, file=None, chain=True)",
    "description": "This is a shorthand for 'print_exception(sys.last_type,"
  },
  "760": {
    "name": "print_list",
    "module": "jax.lib.xla_client.logging.traceback",
    "fullName": "jax.lib.xla_client.logging.traceback.print_list",
    "signature": "(extracted_list, file=None)",
    "description": "Print the list of tuples as returned by extract_tb() or"
  },
  "761": {
    "name": "print_stack",
    "module": "jax.lib.xla_client.logging.traceback",
    "fullName": "jax.lib.xla_client.logging.traceback.print_stack",
    "signature": "(f=None, limit=None, file=None)",
    "description": "Print a stack trace from its invocation point."
  },
  "762": {
    "name": "print_tb",
    "module": "jax.lib.xla_client.logging.traceback",
    "fullName": "jax.lib.xla_client.logging.traceback.print_tb",
    "signature": "(tb, limit=None, file=None)",
    "description": "Print up to 'limit' stack trace entries from the traceback 'tb'."
  },
  "763": {
    "name": "walk_stack",
    "module": "jax.lib.xla_client.logging.traceback",
    "fullName": "jax.lib.xla_client.logging.traceback.walk_stack",
    "signature": "(f)",
    "description": "Walk a stack yielding the frame and line number for each frame."
  },
  "764": {
    "name": "walk_tb",
    "module": "jax.lib.xla_client.logging.traceback",
    "fullName": "jax.lib.xla_client.logging.traceback.walk_tb",
    "signature": "(tb)",
    "description": "Walk a traceback yielding the frame and line number for each frame."
  },
  "765": {
    "name": "compress",
    "module": "jax.lib.xla_client.gzip",
    "fullName": "jax.lib.xla_client.gzip.compress",
    "signature": "(data, compresslevel=9, *, mtime=None)",
    "description": "Compress data in one shot and return the compressed string."
  },
  "766": {
    "name": "decompress",
    "module": "jax.lib.xla_client.gzip",
    "fullName": "jax.lib.xla_client.gzip.decompress",
    "signature": "(data)",
    "description": "Decompress a gzip compressed string in one shot."
  },
  "767": {
    "name": "main",
    "module": "jax.lib.xla_client.gzip",
    "fullName": "jax.lib.xla_client.gzip.main",
    "signature": "()",
    "description": "No description available."
  },
  "768": {
    "name": "open",
    "module": "jax.lib.xla_client.gzip",
    "fullName": "jax.lib.xla_client.gzip.open",
    "signature": "(filename, mode='rb', compresslevel=9, encoding=None, errors=None, newline=None)",
    "description": "Open a gzip-compressed file in binary or text mode."
  },
  "769": {
    "name": "write32u",
    "module": "jax.lib.xla_client.gzip",
    "fullName": "jax.lib.xla_client.gzip.write32u",
    "signature": "(output, value)",
    "description": "No description available."
  },
  "770": {
    "name": "default_backend",
    "module": "jax.lib.xla_bridge",
    "fullName": "jax.lib.xla_bridge.default_backend",
    "signature": "() -> str",
    "description": "Returns the platform name of the default XLA backend."
  },
  "771": {
    "name": "get_backend",
    "module": "jax.lib.xla_bridge",
    "fullName": "jax.lib.xla_bridge.get_backend",
    "signature": "(platform: Union[NoneType, str, jaxlib.xla_extension.Client] = None) -> jaxlib.xla_extension.Client",
    "description": "No description available."
  },
  "772": {
    "name": "get_compile_options",
    "module": "jax.lib.xla_bridge",
    "fullName": "jax.lib.xla_bridge.get_compile_options",
    "signature": "(num_replicas: int, num_partitions: int, device_assignment=None, use_spmd_partitioning: bool = True, use_auto_spmd_partitioning: bool = False, auto_spmd_partitioning_mesh_shape=[], auto_spmd_partitioning_mesh_ids=[], env_options_overrides: Optional[Dict[str, str]] = None) -> jaxlib.xla_extension.CompileOptions",
    "description": "Returns the compile options to use, as derived from flag values."
  },
  "773": {
    "name": "ConvGeneralDilatedDimensionNumbers",
    "module": "jax.lax",
    "fullName": "jax.lax.ConvGeneralDilatedDimensionNumbers",
    "signature": "(*args, **kwargs)",
    "description": "No description available."
  },
  "774": {
    "name": "abs",
    "module": "jax.lax",
    "fullName": "jax.lax.abs",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise absolute value: :math:`|x|`."
  },
  "775": {
    "name": "acos",
    "module": "jax.lax",
    "fullName": "jax.lax.acos",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise arc cosine: :math:`\\mathrm{acos}(x)`."
  },
  "776": {
    "name": "acosh",
    "module": "jax.lax",
    "fullName": "jax.lax.acosh",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise inverse hyperbolic cosine: :math:`\\mathrm{acosh}(x)`."
  },
  "777": {
    "name": "add",
    "module": "jax.lax",
    "fullName": "jax.lax.add",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], y: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise addition: :math:`x + y`."
  },
  "778": {
    "name": "after_all",
    "module": "jax.lax",
    "fullName": "jax.lax.after_all",
    "signature": "(*operands)",
    "description": "Merges one or more XLA token values. Experimental."
  },
  "779": {
    "name": "all_gather",
    "module": "jax.lax",
    "fullName": "jax.lax.all_gather",
    "signature": "(x, axis_name, *, axis_index_groups=None, axis=0, tiled=False)",
    "description": "Gather values of x across all replicas."
  },
  "780": {
    "name": "all_to_all",
    "module": "jax.lax",
    "fullName": "jax.lax.all_to_all",
    "signature": "(x, axis_name, split_axis, concat_axis, *, axis_index_groups=None, tiled=False)",
    "description": "Materialize the mapped axis and map a different axis."
  },
  "781": {
    "name": "approx_max_k",
    "module": "jax.lax",
    "fullName": "jax.lax.approx_max_k",
    "signature": "(operand: Any, k: int, reduction_dimension: int = -1, recall_target: float = 0.95, reduction_input_size_override: int = -1, aggregate_to_topk: bool = True) -> Tuple[Any, Any]",
    "description": "Returns max ``k`` values and their indices of the ``operand`` in an approximate manner."
  },
  "782": {
    "name": "approx_min_k",
    "module": "jax.lax",
    "fullName": "jax.lax.approx_min_k",
    "signature": "(operand: Any, k: int, reduction_dimension: int = -1, recall_target: float = 0.95, reduction_input_size_override: int = -1, aggregate_to_topk: bool = True) -> Tuple[Any, Any]",
    "description": "Returns min ``k`` values and their indices of the ``operand`` in an approximate manner."
  },
  "783": {
    "name": "argmax",
    "module": "jax.lax",
    "fullName": "jax.lax.argmax",
    "signature": "(operand: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], axis: int, index_dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType]) -> jax.Array",
    "description": "Computes the index of the maximum element along ``axis``."
  },
  "784": {
    "name": "argmin",
    "module": "jax.lax",
    "fullName": "jax.lax.argmin",
    "signature": "(operand: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], axis: int, index_dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType]) -> jax.Array",
    "description": "Computes the index of the minimum element along ``axis``."
  },
  "785": {
    "name": "asin",
    "module": "jax.lax",
    "fullName": "jax.lax.asin",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise arc sine: :math:`\\mathrm{asin}(x)`."
  },
  "786": {
    "name": "asinh",
    "module": "jax.lax",
    "fullName": "jax.lax.asinh",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise inverse hyperbolic sine: :math:`\\mathrm{asinh}(x)`."
  },
  "787": {
    "name": "associative_scan",
    "module": "jax.lax",
    "fullName": "jax.lax.associative_scan",
    "signature": "(fn: Callable, elems, reverse: bool = False, axis: int = 0)",
    "description": "Performs a scan with an associative binary operation, in parallel."
  },
  "788": {
    "name": "atan",
    "module": "jax.lax",
    "fullName": "jax.lax.atan",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise arc tangent: :math:`\\mathrm{atan}(x)`."
  },
  "789": {
    "name": "atan2",
    "module": "jax.lax",
    "fullName": "jax.lax.atan2",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], y: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise arc tangent of two variables:"
  },
  "790": {
    "name": "atanh",
    "module": "jax.lax",
    "fullName": "jax.lax.atanh",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise inverse hyperbolic tangent: :math:`\\mathrm{atanh}(x)`."
  },
  "791": {
    "name": "axis_index",
    "module": "jax.lax",
    "fullName": "jax.lax.axis_index",
    "signature": "(axis_name)",
    "description": "Return the index along the mapped axis ``axis_name``."
  },
  "792": {
    "name": "batch_matmul",
    "module": "jax.lax",
    "fullName": "jax.lax.batch_matmul",
    "signature": "(lhs: jax.Array, rhs: jax.Array, precision: Union[NoneType, str, jax._src.lax.lax.Precision, Tuple[str, str], Tuple[jax._src.lax.lax.Precision, jax._src.lax.lax.Precision]] = None) -> jax.Array",
    "description": "Batch matrix multiplication."
  },
  "793": {
    "name": "bessel_i0e",
    "module": "jax.lax",
    "fullName": "jax.lax.bessel_i0e",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Exponentially scaled modified Bessel function of order 0:"
  },
  "794": {
    "name": "bessel_i1e",
    "module": "jax.lax",
    "fullName": "jax.lax.bessel_i1e",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Exponentially scaled modified Bessel function of order 1:"
  },
  "795": {
    "name": "betainc",
    "module": "jax.lax",
    "fullName": "jax.lax.betainc",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], b: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise regularized incomplete beta integral."
  },
  "796": {
    "name": "bitcast_convert_type",
    "module": "jax.lax",
    "fullName": "jax.lax.bitcast_convert_type",
    "signature": "(operand: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], new_dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType]) -> jax.Array",
    "description": "Elementwise bitcast."
  },
  "797": {
    "name": "bitwise_and",
    "module": "jax.lax",
    "fullName": "jax.lax.bitwise_and",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], y: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise AND: :math:`x \\wedge y`."
  },
  "798": {
    "name": "bitwise_not",
    "module": "jax.lax",
    "fullName": "jax.lax.bitwise_not",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise NOT: :math:`\\neg x`."
  },
  "799": {
    "name": "bitwise_or",
    "module": "jax.lax",
    "fullName": "jax.lax.bitwise_or",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], y: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise OR: :math:`x \\vee y`."
  },
  "800": {
    "name": "bitwise_xor",
    "module": "jax.lax",
    "fullName": "jax.lax.bitwise_xor",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], y: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise exclusive OR: :math:`x \\oplus y`."
  },
  "801": {
    "name": "broadcast",
    "module": "jax.lax",
    "fullName": "jax.lax.broadcast",
    "signature": "(operand: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], sizes: Sequence[int]) -> jax.Array",
    "description": "Broadcasts an array, adding new leading dimensions"
  },
  "802": {
    "name": "broadcast_in_dim",
    "module": "jax.lax",
    "fullName": "jax.lax.broadcast_in_dim",
    "signature": "(operand: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], shape: Sequence[Union[int, Any]], broadcast_dimensions: Sequence[int]) -> jax.Array",
    "description": "Wraps XLA's `BroadcastInDim"
  },
  "803": {
    "name": "broadcast_shapes",
    "module": "jax.lax",
    "fullName": "jax.lax.broadcast_shapes",
    "signature": "(*shapes)",
    "description": "Returns the shape that results from NumPy broadcasting of `shapes`."
  },
  "804": {
    "name": "broadcast_to_rank",
    "module": "jax.lax",
    "fullName": "jax.lax.broadcast_to_rank",
    "signature": "(x: jax.Array, rank: int) -> jax.Array",
    "description": "Adds leading dimensions of ``1`` to give ``x`` rank ``rank``."
  },
  "805": {
    "name": "broadcasted_iota",
    "module": "jax.lax",
    "fullName": "jax.lax.broadcasted_iota",
    "signature": "(dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType], shape: Sequence[Union[int, Any]], dimension: int) -> jax.Array",
    "description": "Convenience wrapper around ``iota``."
  },
  "806": {
    "name": "cbrt",
    "module": "jax.lax",
    "fullName": "jax.lax.cbrt",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise cube root: :math:`\\sqrt[3]{x}`."
  },
  "807": {
    "name": "ceil",
    "module": "jax.lax",
    "fullName": "jax.lax.ceil",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise ceiling: :math:`\\left\\lceil x \\right\\rceil`."
  },
  "808": {
    "name": "clamp",
    "module": "jax.lax",
    "fullName": "jax.lax.clamp",
    "signature": "(min: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], max: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise clamp."
  },
  "809": {
    "name": "clz",
    "module": "jax.lax",
    "fullName": "jax.lax.clz",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise count-leading-zeros."
  },
  "810": {
    "name": "collapse",
    "module": "jax.lax",
    "fullName": "jax.lax.collapse",
    "signature": "(operand: jax.Array, start_dimension: int, stop_dimension: int) -> jax.Array",
    "description": "Collapses dimensions of an array into a single dimension."
  },
  "811": {
    "name": "complex",
    "module": "jax.lax",
    "fullName": "jax.lax.complex",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], y: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise make complex number: :math:`x + jy`."
  },
  "812": {
    "name": "concatenate",
    "module": "jax.lax",
    "fullName": "jax.lax.concatenate",
    "signature": "(operands: Union[jax.Array, Sequence[Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]]], dimension: int) -> jax.Array",
    "description": "Concatenates a sequence of arrays along `dimension`."
  },
  "813": {
    "name": "cond",
    "module": "jax.lax",
    "fullName": "jax.lax.cond",
    "signature": "(pred, true_fun: Callable, false_fun: Callable, *operands, operand=<object object at 0x00000267B34875D0>, linear=None)",
    "description": "Conditionally apply ``true_fun`` or ``false_fun``."
  },
  "814": {
    "name": "conj",
    "module": "jax.lax",
    "fullName": "jax.lax.conj",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise complex conjugate function: :math:`\\overline{x}`."
  },
  "815": {
    "name": "conv",
    "module": "jax.lax",
    "fullName": "jax.lax.conv",
    "signature": "(lhs: Any, rhs: Any, window_strides: Sequence[int], padding: str, precision: Union[NoneType, str, jax._src.lax.lax.Precision, Tuple[str, str], Tuple[jax._src.lax.lax.Precision, jax._src.lax.lax.Precision]] = None, preferred_element_type: Optional[Any] = None) -> Any",
    "description": "Convenience wrapper around `conv_general_dilated`."
  },
  "816": {
    "name": "conv_dimension_numbers",
    "module": "jax.lax",
    "fullName": "jax.lax.conv_dimension_numbers",
    "signature": "(lhs_shape, rhs_shape, dimension_numbers) -> jax._src.lax.convolution.ConvDimensionNumbers",
    "description": "Converts convolution `dimension_numbers` to a `ConvDimensionNumbers`."
  },
  "817": {
    "name": "conv_general_dilated",
    "module": "jax.lax",
    "fullName": "jax.lax.conv_general_dilated",
    "signature": "(lhs: Any, rhs: Any, window_strides: Sequence[int], padding: Union[str, Sequence[Tuple[int, int]]], lhs_dilation: Optional[Sequence[int]] = None, rhs_dilation: Optional[Sequence[int]] = None, dimension_numbers: Union[NoneType, jax._src.lax.convolution.ConvDimensionNumbers, Tuple[str, str, str]] = None, feature_group_count: int = 1, batch_group_count: int = 1, precision: Union[NoneType, str, jax._src.lax.lax.Precision, Tuple[str, str], Tuple[jax._src.lax.lax.Precision, jax._src.lax.lax.Precision]] = None, preferred_element_type: Optional[Any] = None) -> Any",
    "description": "General n-dimensional convolution operator, with optional dilation."
  },
  "818": {
    "name": "conv_general_dilated_local",
    "module": "jax.lax",
    "fullName": "jax.lax.conv_general_dilated_local",
    "signature": "(lhs: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], rhs: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], window_strides: Sequence[int], padding: Union[str, Sequence[Tuple[int, int]]], filter_shape: Sequence[int], lhs_dilation: Optional[Sequence[int]] = None, rhs_dilation: Optional[Sequence[int]] = None, dimension_numbers: Union[NoneType, jax._src.lax.convolution.ConvDimensionNumbers, Tuple[str, str, str]] = None, precision: Union[NoneType, str, jax._src.lax.lax.Precision, Tuple[str, str], Tuple[jax._src.lax.lax.Precision, jax._src.lax.lax.Precision]] = None) -> jax.Array",
    "description": "General n-dimensional unshared convolution operator with optional dilation."
  },
  "819": {
    "name": "conv_general_dilated_patches",
    "module": "jax.lax",
    "fullName": "jax.lax.conv_general_dilated_patches",
    "signature": "(lhs: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], filter_shape: Sequence[int], window_strides: Sequence[int], padding: Union[str, Sequence[Tuple[int, int]]], lhs_dilation: Optional[Sequence[int]] = None, rhs_dilation: Optional[Sequence[int]] = None, dimension_numbers: Union[NoneType, jax._src.lax.convolution.ConvDimensionNumbers, Tuple[str, str, str]] = None, precision: Optional[jax._src.lax.lax.Precision] = None, preferred_element_type: Optional[Any] = None) -> jax.Array",
    "description": "Extract patches subject to the receptive field of `conv_general_dilated`."
  },
  "820": {
    "name": "conv_general_permutations",
    "module": "jax.lax",
    "fullName": "jax.lax.conv_general_permutations",
    "signature": "(dimension_numbers)",
    "description": "Utility for convolution dimension permutations relative to Conv HLO."
  },
  "821": {
    "name": "conv_general_shape_tuple",
    "module": "jax.lax",
    "fullName": "jax.lax.conv_general_shape_tuple",
    "signature": "(lhs_shape, rhs_shape, window_strides, padding, dimension_numbers)",
    "description": "No description available."
  },
  "822": {
    "name": "conv_shape_tuple",
    "module": "jax.lax",
    "fullName": "jax.lax.conv_shape_tuple",
    "signature": "(lhs_shape, rhs_shape, strides, pads, batch_group_count=1)",
    "description": "Compute the shape tuple of a conv given input shapes in canonical order."
  },
  "823": {
    "name": "conv_transpose",
    "module": "jax.lax",
    "fullName": "jax.lax.conv_transpose",
    "signature": "(lhs: Any, rhs: Any, strides: Sequence[int], padding: Union[str, Sequence[Tuple[int, int]]], rhs_dilation: Optional[Sequence[int]] = None, dimension_numbers: Union[NoneType, jax._src.lax.convolution.ConvDimensionNumbers, Tuple[str, str, str]] = None, transpose_kernel: bool = False, precision: Union[NoneType, str, jax._src.lax.lax.Precision, Tuple[str, str], Tuple[jax._src.lax.lax.Precision, jax._src.lax.lax.Precision]] = None, preferred_element_type: Optional[Any] = None) -> Any",
    "description": "Convenience wrapper for calculating the N-d convolution \"transpose\"."
  },
  "824": {
    "name": "conv_transpose_shape_tuple",
    "module": "jax.lax",
    "fullName": "jax.lax.conv_transpose_shape_tuple",
    "signature": "(lhs_shape, rhs_shape, window_strides, padding, dimension_numbers)",
    "description": "No description available."
  },
  "825": {
    "name": "conv_with_general_padding",
    "module": "jax.lax",
    "fullName": "jax.lax.conv_with_general_padding",
    "signature": "(lhs: Any, rhs: Any, window_strides: Sequence[int], padding: Union[str, Sequence[Tuple[int, int]]], lhs_dilation: Optional[Sequence[int]], rhs_dilation: Optional[Sequence[int]], precision: Union[NoneType, str, jax._src.lax.lax.Precision, Tuple[str, str], Tuple[jax._src.lax.lax.Precision, jax._src.lax.lax.Precision]] = None, preferred_element_type: Optional[Any] = None) -> Any",
    "description": "Convenience wrapper around `conv_general_dilated`."
  },
  "826": {
    "name": "convert_element_type",
    "module": "jax.lax",
    "fullName": "jax.lax.convert_element_type",
    "signature": "(operand: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], new_dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType]) -> jax.Array",
    "description": "Elementwise cast."
  },
  "827": {
    "name": "cos",
    "module": "jax.lax",
    "fullName": "jax.lax.cos",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise cosine: :math:`\\mathrm{cos}(x)`."
  },
  "828": {
    "name": "cosh",
    "module": "jax.lax",
    "fullName": "jax.lax.cosh",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise hyperbolic cosine: :math:`\\mathrm{cosh}(x)`."
  },
  "829": {
    "name": "create_token",
    "module": "jax.lax",
    "fullName": "jax.lax.create_token",
    "signature": "(_=None)",
    "description": "Creates an XLA token value with no preconditions for sequencing effects."
  },
  "830": {
    "name": "cumlogsumexp",
    "module": "jax.lax",
    "fullName": "jax.lax.cumlogsumexp",
    "signature": "(operand: Any, axis: int = 0, reverse: bool = False) -> Any",
    "description": "Computes a cumulative logsumexp along `axis`."
  },
  "831": {
    "name": "cummax",
    "module": "jax.lax",
    "fullName": "jax.lax.cummax",
    "signature": "(operand: Any, axis: int = 0, reverse: bool = False) -> Any",
    "description": "Computes a cumulative maximum along `axis`."
  },
  "832": {
    "name": "cummin",
    "module": "jax.lax",
    "fullName": "jax.lax.cummin",
    "signature": "(operand: Any, axis: int = 0, reverse: bool = False) -> Any",
    "description": "Computes a cumulative minimum along `axis`."
  },
  "833": {
    "name": "cumprod",
    "module": "jax.lax",
    "fullName": "jax.lax.cumprod",
    "signature": "(operand: Any, axis: int = 0, reverse: bool = False) -> Any",
    "description": "Computes a cumulative product along `axis`."
  },
  "834": {
    "name": "cumsum",
    "module": "jax.lax",
    "fullName": "jax.lax.cumsum",
    "signature": "(operand: Any, axis: int = 0, reverse: bool = False) -> Any",
    "description": "Computes a cumulative sum along `axis`."
  },
  "835": {
    "name": "custom_linear_solve",
    "module": "jax.lax",
    "fullName": "jax.lax.custom_linear_solve",
    "signature": "(matvec, b, solve, transpose_solve=None, symmetric=False, has_aux=False)",
    "description": "Perform a matrix-free linear solve with implicitly defined gradients."
  },
  "836": {
    "name": "custom_root",
    "module": "jax.lax",
    "fullName": "jax.lax.custom_root",
    "signature": "(f, initial_guess, solve, tangent_solve, has_aux=False)",
    "description": "Differentiably solve for a roots of a function."
  },
  "837": {
    "name": "digamma",
    "module": "jax.lax",
    "fullName": "jax.lax.digamma",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise digamma: :math:`\\psi(x)`."
  },
  "838": {
    "name": "div",
    "module": "jax.lax",
    "fullName": "jax.lax.div",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], y: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise division: :math:`x \\over y`."
  },
  "839": {
    "name": "dot",
    "module": "jax.lax",
    "fullName": "jax.lax.dot",
    "signature": "(lhs: jax.Array, rhs: jax.Array, precision: Union[NoneType, str, jax._src.lax.lax.Precision, Tuple[str, str], Tuple[jax._src.lax.lax.Precision, jax._src.lax.lax.Precision]] = None, preferred_element_type: Union[Any, str, numpy.dtype, jax._src.SupportsDType, NoneType] = None) -> jax.Array",
    "description": "Vector/vector, matrix/vector, and matrix/matrix multiplication."
  },
  "840": {
    "name": "dot_general",
    "module": "jax.lax",
    "fullName": "jax.lax.dot_general",
    "signature": "(lhs: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], rhs: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], dimension_numbers: Tuple[Tuple[Sequence[int], Sequence[int]], Tuple[Sequence[int], Sequence[int]]], precision: Union[NoneType, str, jax._src.lax.lax.Precision, Tuple[str, str], Tuple[jax._src.lax.lax.Precision, jax._src.lax.lax.Precision]] = None, preferred_element_type: Union[Any, str, numpy.dtype, jax._src.SupportsDType, NoneType] = None) -> jax.Array",
    "description": "General dot product/contraction operator."
  },
  "841": {
    "name": "dynamic_index_in_dim",
    "module": "jax.lax",
    "fullName": "jax.lax.dynamic_index_in_dim",
    "signature": "(operand: Union[jax.Array, numpy.ndarray], index: Union[int, jax.Array], axis: int = 0, keepdims: bool = True) -> jax.Array",
    "description": "Convenience wrapper around dynamic_slice to perform int indexing."
  },
  "842": {
    "name": "dynamic_slice",
    "module": "jax.lax",
    "fullName": "jax.lax.dynamic_slice",
    "signature": "(operand: Union[jax.Array, numpy.ndarray], start_indices: Union[jax.Array, numpy.ndarray, Sequence[Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]]], slice_sizes: Sequence[Union[int, Any]]) -> jax.Array",
    "description": "Wraps XLA's `DynamicSlice"
  },
  "843": {
    "name": "dynamic_slice_in_dim",
    "module": "jax.lax",
    "fullName": "jax.lax.dynamic_slice_in_dim",
    "signature": "(operand: Union[jax.Array, numpy.ndarray], start_index: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], slice_size: int, axis: int = 0) -> jax.Array",
    "description": "Convenience wrapper around dynamic_slice applying to one dimension."
  },
  "844": {
    "name": "dynamic_update_index_in_dim",
    "module": "jax.lax",
    "fullName": "jax.lax.dynamic_update_index_in_dim",
    "signature": "(operand: Union[jax.Array, numpy.ndarray], update: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], index: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], axis: int) -> jax.Array",
    "description": "Convenience wrapper around :func:`dynamic_update_slice` to update a slice"
  },
  "845": {
    "name": "dynamic_update_slice",
    "module": "jax.lax",
    "fullName": "jax.lax.dynamic_update_slice",
    "signature": "(operand: Union[jax.Array, numpy.ndarray], update: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], start_indices: Union[jax.Array, Sequence[Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]]]) -> jax.Array",
    "description": "Wraps XLA's `DynamicUpdateSlice"
  },
  "846": {
    "name": "dynamic_update_slice_in_dim",
    "module": "jax.lax",
    "fullName": "jax.lax.dynamic_update_slice_in_dim",
    "signature": "(operand: Union[jax.Array, numpy.ndarray], update: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], start_index: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], axis: int) -> jax.Array",
    "description": "Convenience wrapper around :func:`dynamic_update_slice` to update a slice"
  },
  "847": {
    "name": "eq",
    "module": "jax.lax",
    "fullName": "jax.lax.eq",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], y: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise equals: :math:`x = y`."
  },
  "848": {
    "name": "erf",
    "module": "jax.lax",
    "fullName": "jax.lax.erf",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise error function: :math:`\\mathrm{erf}(x)`."
  },
  "849": {
    "name": "erf_inv",
    "module": "jax.lax",
    "fullName": "jax.lax.erf_inv",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise inverse error function: :math:`\\mathrm{erf}^{-1}(x)`."
  },
  "850": {
    "name": "erfc",
    "module": "jax.lax",
    "fullName": "jax.lax.erfc",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise complementary error function:"
  },
  "851": {
    "name": "exp",
    "module": "jax.lax",
    "fullName": "jax.lax.exp",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise exponential: :math:`e^x`."
  },
  "852": {
    "name": "expand_dims",
    "module": "jax.lax",
    "fullName": "jax.lax.expand_dims",
    "signature": "(array: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], dimensions: Sequence[int]) -> jax.Array",
    "description": "Insert any number of size 1 dimensions into an array."
  },
  "853": {
    "name": "expm1",
    "module": "jax.lax",
    "fullName": "jax.lax.expm1",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise :math:`e^{x} - 1`."
  },
  "854": {
    "name": "fft",
    "module": "jax.lax",
    "fullName": "jax.lax.fft",
    "signature": "(x, fft_type: Union[jaxlib.xla_extension.FftType, str], fft_lengths: Sequence[int])",
    "description": "No description available."
  },
  "855": {
    "name": "floor",
    "module": "jax.lax",
    "fullName": "jax.lax.floor",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise floor: :math:`\\left\\lfloor x \\right\\rfloor`."
  },
  "856": {
    "name": "fori_loop",
    "module": "jax.lax",
    "fullName": "jax.lax.fori_loop",
    "signature": "(lower, upper, body_fun, init_val)",
    "description": "Loop from ``lower`` to ``upper`` by reduction to :func:`jax.lax.while_loop`."
  },
  "857": {
    "name": "full",
    "module": "jax.lax",
    "fullName": "jax.lax.full",
    "signature": "(shape: Sequence[Union[int, Any]], fill_value: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType, NoneType] = None) -> jax.Array",
    "description": "Returns an array of `shape` filled with `fill_value`."
  },
  "858": {
    "name": "full_like",
    "module": "jax.lax",
    "fullName": "jax.lax.full_like",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, jax._src.DuckTypedArray], fill_value: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType, NoneType] = None, shape: Optional[Sequence[Union[int, Any]]] = None) -> jax.Array",
    "description": "Create a full array like np.full based on the example array `x`."
  },
  "859": {
    "name": "gather",
    "module": "jax.lax",
    "fullName": "jax.lax.gather",
    "signature": "(operand: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], start_indices: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], dimension_numbers: jax._src.lax.slicing.GatherDimensionNumbers, slice_sizes: Sequence[Union[int, Any]], *, unique_indices: bool = False, indices_are_sorted: bool = False, mode: Union[str, jax._src.lax.slicing.GatherScatterMode, NoneType] = None, fill_value=None) -> jax.Array",
    "description": "Gather operator."
  },
  "860": {
    "name": "ge",
    "module": "jax.lax",
    "fullName": "jax.lax.ge",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], y: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise greater-than-or-equals: :math:`x \\geq y`."
  },
  "861": {
    "name": "gt",
    "module": "jax.lax",
    "fullName": "jax.lax.gt",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], y: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise greater-than: :math:`x > y`."
  },
  "862": {
    "name": "igamma",
    "module": "jax.lax",
    "fullName": "jax.lax.igamma",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise regularized incomplete gamma function."
  },
  "863": {
    "name": "igamma_grad_a",
    "module": "jax.lax",
    "fullName": "jax.lax.igamma_grad_a",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise derivative of the regularized incomplete gamma function."
  },
  "864": {
    "name": "igammac",
    "module": "jax.lax",
    "fullName": "jax.lax.igammac",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise complementary regularized incomplete gamma function."
  },
  "865": {
    "name": "imag",
    "module": "jax.lax",
    "fullName": "jax.lax.imag",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise extract imaginary part: :math:`\\mathrm{Im}(x)`."
  },
  "866": {
    "name": "index_in_dim",
    "module": "jax.lax",
    "fullName": "jax.lax.index_in_dim",
    "signature": "(operand: Union[jax.Array, numpy.ndarray], index: int, axis: int = 0, keepdims: bool = True) -> jax.Array",
    "description": "Convenience wrapper around slice to perform int indexing."
  },
  "867": {
    "name": "index_take",
    "module": "jax.lax",
    "fullName": "jax.lax.index_take",
    "signature": "(src: jax.Array, idxs: jax.Array, axes: Sequence[int]) -> jax.Array",
    "description": "No description available."
  },
  "868": {
    "name": "infeed",
    "module": "jax.lax",
    "fullName": "jax.lax.infeed",
    "signature": "(token, shape=None, partitions=None)",
    "description": "Consumes an infeed value of `shape` from the host. Experimental."
  },
  "869": {
    "name": "integer_pow",
    "module": "jax.lax",
    "fullName": "jax.lax.integer_pow",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], y: int) -> jax.Array",
    "description": "Elementwise power: :math:`x^y`, where :math:`y` is a fixed integer."
  },
  "870": {
    "name": "iota",
    "module": "jax.lax",
    "fullName": "jax.lax.iota",
    "signature": "(dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType], size: int) -> jax.Array",
    "description": "Wraps XLA's `Iota"
  },
  "871": {
    "name": "is_finite",
    "module": "jax.lax",
    "fullName": "jax.lax.is_finite",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise :math:`\\mathrm{isfinite}`."
  },
  "872": {
    "name": "le",
    "module": "jax.lax",
    "fullName": "jax.lax.le",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], y: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise less-than-or-equals: :math:`x \\leq y`."
  },
  "873": {
    "name": "lgamma",
    "module": "jax.lax",
    "fullName": "jax.lax.lgamma",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise log gamma: :math:`\\mathrm{log}(\\Gamma(x))`."
  },
  "874": {
    "name": "log",
    "module": "jax.lax",
    "fullName": "jax.lax.log",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise natural logarithm: :math:`\\mathrm{log}(x)`."
  },
  "875": {
    "name": "log1p",
    "module": "jax.lax",
    "fullName": "jax.lax.log1p",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise :math:`\\mathrm{log}(1 + x)`."
  },
  "876": {
    "name": "logistic",
    "module": "jax.lax",
    "fullName": "jax.lax.logistic",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise logistic (sigmoid) function: :math:`\\frac{1}{1 + e^{-x}}`."
  },
  "877": {
    "name": "lt",
    "module": "jax.lax",
    "fullName": "jax.lax.lt",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], y: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise less-than: :math:`x < y`."
  },
  "878": {
    "name": "map",
    "module": "jax.lax",
    "fullName": "jax.lax.map",
    "signature": "(f, xs)",
    "description": "Map a function over leading array axes."
  },
  "879": {
    "name": "max",
    "module": "jax.lax",
    "fullName": "jax.lax.max",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], y: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise maximum: :math:`\\mathrm{max}(x, y)`"
  },
  "880": {
    "name": "min",
    "module": "jax.lax",
    "fullName": "jax.lax.min",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], y: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise minimum:  :math:`\\mathrm{min}(x, y)`"
  },
  "881": {
    "name": "mul",
    "module": "jax.lax",
    "fullName": "jax.lax.mul",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], y: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise multiplication: :math:`x \\times y`."
  },
  "882": {
    "name": "naryop",
    "module": "jax.lax",
    "fullName": "jax.lax.naryop",
    "signature": "(result_dtype, accepted_dtypes, name, allow_opaque_dtype=False)",
    "description": "No description available."
  },
  "883": {
    "name": "naryop_dtype_rule",
    "module": "jax.lax",
    "fullName": "jax.lax.naryop_dtype_rule",
    "signature": "(result_dtype, accepted_dtypes, name, *avals, allow_opaque_dtype=False, **kwargs)",
    "description": "No description available."
  },
  "884": {
    "name": "ne",
    "module": "jax.lax",
    "fullName": "jax.lax.ne",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], y: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise not-equals: :math:`x \\neq y`."
  },
  "885": {
    "name": "neg",
    "module": "jax.lax",
    "fullName": "jax.lax.neg",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise negation: :math:`-x`."
  },
  "886": {
    "name": "nextafter",
    "module": "jax.lax",
    "fullName": "jax.lax.nextafter",
    "signature": "(x1: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], x2: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Returns the next representable value after `x1` in the direction of `x2`."
  },
  "887": {
    "name": "outfeed",
    "module": "jax.lax",
    "fullName": "jax.lax.outfeed",
    "signature": "(token, xs, partitions=None)",
    "description": "Outfeeds value `xs` to the host. Experimental."
  },
  "888": {
    "name": "pad",
    "module": "jax.lax",
    "fullName": "jax.lax.pad",
    "signature": "(operand: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], padding_value: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], padding_config: Sequence[Tuple[int, int, int]]) -> jax.Array",
    "description": "Applies low, high, and/or interior padding to an array."
  },
  "889": {
    "name": "padtype_to_pads",
    "module": "jax.lax",
    "fullName": "jax.lax.padtype_to_pads",
    "signature": "(in_shape, window_shape, window_strides, padding)",
    "description": "Convert padding string to list of pairs of pad values."
  },
  "890": {
    "name": "pdot",
    "module": "jax.lax",
    "fullName": "jax.lax.pdot",
    "signature": "(x, y, axis_name, pos_contract=((), ()), pos_batch=((), ()), precision=None)",
    "description": "No description available."
  },
  "891": {
    "name": "pmax",
    "module": "jax.lax",
    "fullName": "jax.lax.pmax",
    "signature": "(x, axis_name, *, axis_index_groups=None)",
    "description": "Compute an all-reduce max on ``x`` over the pmapped axis ``axis_name``."
  },
  "892": {
    "name": "pmean",
    "module": "jax.lax",
    "fullName": "jax.lax.pmean",
    "signature": "(x, axis_name, *, axis_index_groups=None)",
    "description": "Compute an all-reduce mean on ``x`` over the pmapped axis ``axis_name``."
  },
  "893": {
    "name": "pmin",
    "module": "jax.lax",
    "fullName": "jax.lax.pmin",
    "signature": "(x, axis_name, *, axis_index_groups=None)",
    "description": "Compute an all-reduce min on ``x`` over the pmapped axis ``axis_name``."
  },
  "894": {
    "name": "population_count",
    "module": "jax.lax",
    "fullName": "jax.lax.population_count",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise popcount, count the number of set bits in each element."
  },
  "895": {
    "name": "pow",
    "module": "jax.lax",
    "fullName": "jax.lax.pow",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], y: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise power: :math:`x^y`."
  },
  "896": {
    "name": "ppermute",
    "module": "jax.lax",
    "fullName": "jax.lax.ppermute",
    "signature": "(x, axis_name, perm)",
    "description": "Perform a collective permutation according to the permutation ``perm``."
  },
  "897": {
    "name": "pshuffle",
    "module": "jax.lax",
    "fullName": "jax.lax.pshuffle",
    "signature": "(x, axis_name, perm)",
    "description": "Convenience wrapper of jax.lax.ppermute with alternate permutation encoding"
  },
  "898": {
    "name": "psum",
    "module": "jax.lax",
    "fullName": "jax.lax.psum",
    "signature": "(x, axis_name, *, axis_index_groups=None)",
    "description": "Compute an all-reduce sum on ``x`` over the pmapped axis ``axis_name``."
  },
  "899": {
    "name": "psum_scatter",
    "module": "jax.lax",
    "fullName": "jax.lax.psum_scatter",
    "signature": "(x, axis_name, *, scatter_dimension=0, axis_index_groups=None, tiled=False)",
    "description": "Compute an all-reduce sum over the axis ``axis_name``, and scatter the result."
  },
  "900": {
    "name": "pswapaxes",
    "module": "jax.lax",
    "fullName": "jax.lax.pswapaxes",
    "signature": "(x, axis_name, axis, *, axis_index_groups=None)",
    "description": "Swap the pmapped axis ``axis_name`` with the unmapped axis ``axis``."
  },
  "901": {
    "name": "random_gamma_grad",
    "module": "jax.lax",
    "fullName": "jax.lax.random_gamma_grad",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise derivative of samples from `Gamma(a, 1)`."
  },
  "902": {
    "name": "real",
    "module": "jax.lax",
    "fullName": "jax.lax.real",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise extract real part: :math:`\\mathrm{Re}(x)`."
  },
  "903": {
    "name": "reciprocal",
    "module": "jax.lax",
    "fullName": "jax.lax.reciprocal",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise reciprocal: :math:`1 \\over x`."
  },
  "904": {
    "name": "reduce",
    "module": "jax.lax",
    "fullName": "jax.lax.reduce",
    "signature": "(operands: Any, init_values: Any, computation: Callable[[Any, Any], Any], dimensions: Sequence[int]) -> Any",
    "description": "Wraps XLA's `Reduce"
  },
  "905": {
    "name": "reduce_precision",
    "module": "jax.lax",
    "fullName": "jax.lax.reduce_precision",
    "signature": "(operand: Union[float, jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, complex], exponent_bits: int, mantissa_bits: int) -> jax.Array",
    "description": "Wraps XLA's `ReducePrecision"
  },
  "906": {
    "name": "reduce_window",
    "module": "jax.lax",
    "fullName": "jax.lax.reduce_window",
    "signature": "(operand, init_value, computation: Callable, window_dimensions: Sequence[Union[int, Any]], window_strides: Sequence[int], padding: Union[str, Sequence[Tuple[int, int]]], base_dilation: Optional[Sequence[int]] = None, window_dilation: Optional[Sequence[int]] = None) -> Any",
    "description": "Wraps XLA's `ReduceWindowWithGeneralPadding"
  },
  "907": {
    "name": "reduce_window_shape_tuple",
    "module": "jax.lax",
    "fullName": "jax.lax.reduce_window_shape_tuple",
    "signature": "(operand_shape, window_dimensions, window_strides, padding, base_dilation=None, window_dilation=None)",
    "description": "No description available."
  },
  "908": {
    "name": "rem",
    "module": "jax.lax",
    "fullName": "jax.lax.rem",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], y: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise remainder: :math:`x \\bmod y`."
  },
  "909": {
    "name": "reshape",
    "module": "jax.lax",
    "fullName": "jax.lax.reshape",
    "signature": "(operand: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], new_sizes: Sequence[Union[int, Any]], dimensions: Optional[Sequence[int]] = None) -> jax.Array",
    "description": "Wraps XLA's `Reshape"
  },
  "910": {
    "name": "rev",
    "module": "jax.lax",
    "fullName": "jax.lax.rev",
    "signature": "(operand: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], dimensions: Sequence[int]) -> jax.Array",
    "description": "Wraps XLA's `Rev"
  },
  "911": {
    "name": "rng_bit_generator",
    "module": "jax.lax",
    "fullName": "jax.lax.rng_bit_generator",
    "signature": "(key, shape, dtype=<class 'numpy.uint32'>, algorithm=<RandomAlgorithm.RNG_DEFAULT: 0>)",
    "description": "Stateless PRNG bit generator. Experimental and its use is discouraged."
  },
  "912": {
    "name": "rng_uniform",
    "module": "jax.lax",
    "fullName": "jax.lax.rng_uniform",
    "signature": "(a, b, shape)",
    "description": "Stateful PRNG generator. Experimental and its use is discouraged."
  },
  "913": {
    "name": "round",
    "module": "jax.lax",
    "fullName": "jax.lax.round",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], rounding_method: jax._src.lax.lax.RoundingMethod = <RoundingMethod.AWAY_FROM_ZERO: 0>) -> jax.Array",
    "description": "Elementwise round."
  },
  "914": {
    "name": "rsqrt",
    "module": "jax.lax",
    "fullName": "jax.lax.rsqrt",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise reciprocal square root:  :math:`1 \\over \\sqrt{x}`."
  },
  "915": {
    "name": "scan",
    "module": "jax.lax",
    "fullName": "jax.lax.scan",
    "signature": "(f: Callable[[~Carry, ~X], Tuple[~Carry, ~Y]], init: ~Carry, xs: ~X, length: Optional[int] = None, reverse: bool = False, unroll: int = 1) -> Tuple[~Carry, ~Y]",
    "description": "Scan a function over leading array axes while carrying along state."
  },
  "916": {
    "name": "scan_bind",
    "module": "jax.lax",
    "fullName": "jax.lax.scan_bind",
    "signature": "(*args, **params)",
    "description": "No description available."
  },
  "917": {
    "name": "scatter",
    "module": "jax.lax",
    "fullName": "jax.lax.scatter",
    "signature": "(operand: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], scatter_indices: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], updates: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], dimension_numbers: jax._src.lax.slicing.ScatterDimensionNumbers, *, indices_are_sorted: bool = False, unique_indices: bool = False, mode: Union[str, jax._src.lax.slicing.GatherScatterMode, NoneType] = None) -> jax.Array",
    "description": "Scatter-update operator."
  },
  "918": {
    "name": "scatter_add",
    "module": "jax.lax",
    "fullName": "jax.lax.scatter_add",
    "signature": "(operand: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], scatter_indices: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], updates: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], dimension_numbers: jax._src.lax.slicing.ScatterDimensionNumbers, *, indices_are_sorted: bool = False, unique_indices: bool = False, mode: Union[str, jax._src.lax.slicing.GatherScatterMode, NoneType] = None) -> jax.Array",
    "description": "Scatter-add operator."
  },
  "919": {
    "name": "scatter_apply",
    "module": "jax.lax",
    "fullName": "jax.lax.scatter_apply",
    "signature": "(operand: jax.Array, scatter_indices: jax.Array, func: Callable[[jax.Array], jax.Array], dimension_numbers: jax._src.lax.slicing.ScatterDimensionNumbers, *, update_shape: Sequence[Union[int, Any]] = (), indices_are_sorted: bool = False, unique_indices: bool = False, mode: Union[str, jax._src.lax.slicing.GatherScatterMode, NoneType] = None) -> jax.Array",
    "description": "Scatter-apply operator."
  },
  "920": {
    "name": "scatter_max",
    "module": "jax.lax",
    "fullName": "jax.lax.scatter_max",
    "signature": "(operand: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], scatter_indices: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], updates: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], dimension_numbers: jax._src.lax.slicing.ScatterDimensionNumbers, *, indices_are_sorted: bool = False, unique_indices: bool = False, mode: Union[str, jax._src.lax.slicing.GatherScatterMode, NoneType] = None) -> jax.Array",
    "description": "Scatter-max operator."
  },
  "921": {
    "name": "scatter_min",
    "module": "jax.lax",
    "fullName": "jax.lax.scatter_min",
    "signature": "(operand: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], scatter_indices: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], updates: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], dimension_numbers: jax._src.lax.slicing.ScatterDimensionNumbers, *, indices_are_sorted: bool = False, unique_indices: bool = False, mode: Union[str, jax._src.lax.slicing.GatherScatterMode, NoneType] = None) -> jax.Array",
    "description": "Scatter-min operator."
  },
  "922": {
    "name": "scatter_mul",
    "module": "jax.lax",
    "fullName": "jax.lax.scatter_mul",
    "signature": "(operand: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], scatter_indices: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], updates: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], dimension_numbers: jax._src.lax.slicing.ScatterDimensionNumbers, *, indices_are_sorted: bool = False, unique_indices: bool = False, mode: Union[str, jax._src.lax.slicing.GatherScatterMode, NoneType] = None) -> jax.Array",
    "description": "Scatter-multiply operator."
  },
  "923": {
    "name": "select",
    "module": "jax.lax",
    "fullName": "jax.lax.select",
    "signature": "(pred: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], on_true: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], on_false: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Selects between two branches based on a boolean predicate."
  },
  "924": {
    "name": "select_n",
    "module": "jax.lax",
    "fullName": "jax.lax.select_n",
    "signature": "(which: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], *cases: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Selects array values from multiple cases."
  },
  "925": {
    "name": "shift_left",
    "module": "jax.lax",
    "fullName": "jax.lax.shift_left",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], y: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise left shift: :math:`x \\ll y`."
  },
  "926": {
    "name": "shift_right_arithmetic",
    "module": "jax.lax",
    "fullName": "jax.lax.shift_right_arithmetic",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], y: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise arithmetic right shift: :math:`x \\gg y`."
  },
  "927": {
    "name": "shift_right_logical",
    "module": "jax.lax",
    "fullName": "jax.lax.shift_right_logical",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], y: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise logical right shift: :math:`x \\gg y`."
  },
  "928": {
    "name": "sign",
    "module": "jax.lax",
    "fullName": "jax.lax.sign",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise sign."
  },
  "929": {
    "name": "sin",
    "module": "jax.lax",
    "fullName": "jax.lax.sin",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise sine: :math:`\\mathrm{sin}(x)`."
  },
  "930": {
    "name": "sinh",
    "module": "jax.lax",
    "fullName": "jax.lax.sinh",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise hyperbolic sine: :math:`\\mathrm{sinh}(x)`."
  },
  "931": {
    "name": "slice",
    "module": "jax.lax",
    "fullName": "jax.lax.slice",
    "signature": "(operand: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], start_indices: Sequence[int], limit_indices: Sequence[int], strides: Optional[Sequence[int]] = None) -> jax.Array",
    "description": "Wraps XLA's `Slice"
  },
  "932": {
    "name": "slice_in_dim",
    "module": "jax.lax",
    "fullName": "jax.lax.slice_in_dim",
    "signature": "(operand: Union[jax.Array, numpy.ndarray], start_index: Optional[int], limit_index: Optional[int], stride: int = 1, axis: int = 0) -> jax.Array",
    "description": "Convenience wrapper around slice applying to only one dimension."
  },
  "933": {
    "name": "sort",
    "module": "jax.lax",
    "fullName": "jax.lax.sort",
    "signature": "(operand: Union[jax.Array, Sequence[jax.Array]], dimension: int = -1, is_stable: bool = True, num_keys: int = 1) -> Union[jax.Array, Tuple[jax.Array, ...]]",
    "description": "Wraps XLA's `Sort"
  },
  "934": {
    "name": "sort_key_val",
    "module": "jax.lax",
    "fullName": "jax.lax.sort_key_val",
    "signature": "(keys: jax.Array, values: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], dimension: int = -1, is_stable: bool = True) -> Tuple[jax.Array, jax.Array]",
    "description": "Sorts ``keys`` along ``dimension`` and applies the same permutation to ``values``."
  },
  "935": {
    "name": "sqrt",
    "module": "jax.lax",
    "fullName": "jax.lax.sqrt",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise square root: :math:`\\sqrt{x}`."
  },
  "936": {
    "name": "square",
    "module": "jax.lax",
    "fullName": "jax.lax.square",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise square: :math:`x^2`."
  },
  "937": {
    "name": "squeeze",
    "module": "jax.lax",
    "fullName": "jax.lax.squeeze",
    "signature": "(array: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], dimensions: Sequence[int]) -> jax.Array",
    "description": "Squeeze any number of size 1 dimensions from an array."
  },
  "938": {
    "name": "standard_abstract_eval",
    "module": "jax.lax",
    "fullName": "jax.lax.standard_abstract_eval",
    "signature": "(prim, shape_rule, dtype_rule, weak_type_rule, named_shape_rule, *avals, **kwargs)",
    "description": "No description available."
  },
  "939": {
    "name": "standard_primitive",
    "module": "jax.lax",
    "fullName": "jax.lax.standard_primitive",
    "signature": "(shape_rule, dtype_rule, name, translation_rule=None, weak_type_rule=None, named_shape_rule=None)",
    "description": "No description available."
  },
  "940": {
    "name": "stop_gradient",
    "module": "jax.lax",
    "fullName": "jax.lax.stop_gradient",
    "signature": "(x: ~T) -> ~T",
    "description": "Stops gradient computation."
  },
  "941": {
    "name": "sub",
    "module": "jax.lax",
    "fullName": "jax.lax.sub",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], y: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise subtraction: :math:`x - y`."
  },
  "942": {
    "name": "switch",
    "module": "jax.lax",
    "fullName": "jax.lax.switch",
    "signature": "(index, branches: Sequence[Callable], *operands, operand=<object object at 0x00000267B34875D0>)",
    "description": "Apply exactly one of ``branches`` given by ``index``."
  },
  "943": {
    "name": "tan",
    "module": "jax.lax",
    "fullName": "jax.lax.tan",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise tangent: :math:`\\mathrm{tan}(x)`."
  },
  "944": {
    "name": "tanh",
    "module": "jax.lax",
    "fullName": "jax.lax.tanh",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Elementwise hyperbolic tangent: :math:`\\mathrm{tanh}(x)`."
  },
  "945": {
    "name": "tie_in",
    "module": "jax.lax",
    "fullName": "jax.lax.tie_in",
    "signature": "(x: Any, y: ~T) -> ~T",
    "description": "Deprecated. Ignores ``x`` and returns ``y``."
  },
  "946": {
    "name": "top_k",
    "module": "jax.lax",
    "fullName": "jax.lax.top_k",
    "signature": "(operand: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], k: int) -> Tuple[jax.Array, jax.Array]",
    "description": "Returns top ``k`` values and their indices along the last axis of ``operand``."
  },
  "947": {
    "name": "transpose",
    "module": "jax.lax",
    "fullName": "jax.lax.transpose",
    "signature": "(operand: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], permutation: Sequence[int]) -> jax.Array",
    "description": "Wraps XLA's `Transpose"
  },
  "948": {
    "name": "unop",
    "module": "jax.lax",
    "fullName": "jax.lax.unop",
    "signature": "(result_dtype, accepted_dtypes, name)",
    "description": "No description available."
  },
  "949": {
    "name": "unop_dtype_rule",
    "module": "jax.lax",
    "fullName": "jax.lax.unop_dtype_rule",
    "signature": "(result_dtype, accepted_dtypes, name, aval, **kwargs)",
    "description": "No description available."
  },
  "950": {
    "name": "while_loop",
    "module": "jax.lax",
    "fullName": "jax.lax.while_loop",
    "signature": "(cond_fun: Callable[[~T], Any], body_fun: Callable[[~T], ~T], init_val: ~T) -> ~T",
    "description": "Call ``body_fun`` repeatedly in a loop while ``cond_fun`` is True."
  },
  "951": {
    "name": "with_sharding_constraint",
    "module": "jax.lax",
    "fullName": "jax.lax.with_sharding_constraint",
    "signature": "(x, shardings)",
    "description": "Mechanism to constrain the sharding of an Array inside a jitted computation"
  },
  "952": {
    "name": "xeinsum",
    "module": "jax.lax",
    "fullName": "jax.lax.xeinsum",
    "signature": "(spec: str, *operands)",
    "description": "No description available."
  },
  "953": {
    "name": "zeros_like_array",
    "module": "jax.lax",
    "fullName": "jax.lax.zeros_like_array",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "No description available."
  },
  "954": {
    "name": "cholesky",
    "module": "jax.lax.linalg",
    "fullName": "jax.lax.linalg.cholesky",
    "signature": "(x: jax.Array, *, symmetrize_input: bool = True) -> jax.Array",
    "description": "Cholesky decomposition."
  },
  "955": {
    "name": "eig",
    "module": "jax.lax.linalg",
    "fullName": "jax.lax.linalg.eig",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], *, compute_left_eigenvectors: bool = True, compute_right_eigenvectors: bool = True) -> List[jax.Array]",
    "description": "Eigendecomposition of a general matrix."
  },
  "956": {
    "name": "eigh",
    "module": "jax.lax.linalg",
    "fullName": "jax.lax.linalg.eigh",
    "signature": "(x: jax.Array, *, lower: bool = True, symmetrize_input: bool = True, sort_eigenvalues: bool = True) -> Tuple[jax.Array, jax.Array]",
    "description": "Eigendecomposition of a Hermitian matrix."
  },
  "957": {
    "name": "hessenberg",
    "module": "jax.lax.linalg",
    "fullName": "jax.lax.linalg.hessenberg",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> Tuple[jax.Array, jax.Array]",
    "description": "Reduces a square matrix to upper Hessenberg form."
  },
  "958": {
    "name": "householder_product",
    "module": "jax.lax.linalg",
    "fullName": "jax.lax.linalg.householder_product",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], taus: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
    "description": "Product of elementary Householder reflectors."
  },
  "959": {
    "name": "lu",
    "module": "jax.lax.linalg",
    "fullName": "jax.lax.linalg.lu",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> Tuple[jax.Array, jax.Array, jax.Array]",
    "description": "LU decomposition with partial pivoting."
  },
  "960": {
    "name": "lu_pivots_to_permutation",
    "module": "jax.lax.linalg",
    "fullName": "jax.lax.linalg.lu_pivots_to_permutation",
    "signature": "(pivots: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], permutation_size: int) -> jax.Array",
    "description": "Converts the pivots (row swaps) returned by LU to a permutation."
  },
  "961": {
    "name": "qdwh",
    "module": "jax.lax.linalg",
    "fullName": "jax.lax.linalg.qdwh",
    "signature": "(x, *, is_hermitian=False, max_iterations=None, eps=None, dynamic_shape: Optional[Tuple[int, int]] = None)",
    "description": "QR-based dynamically weighted Halley iteration for polar decomposition."
  },
  "962": {
    "name": "qr",
    "module": "jax.lax.linalg",
    "fullName": "jax.lax.linalg.qr",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], *, full_matrices: bool = True) -> Tuple[jax.Array, jax.Array]",
    "description": "QR decomposition."
  },
  "963": {
    "name": "schur",
    "module": "jax.lax.linalg",
    "fullName": "jax.lax.linalg.schur",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], *, compute_schur_vectors: bool = True, sort_eig_vals: bool = False, select_callable: Optional[Callable[..., Any]] = None) -> Tuple[jax.Array, jax.Array]",
    "description": "No description available."
  },
  "964": {
    "name": "svd",
    "module": "jax.lax.linalg",
    "fullName": "jax.lax.linalg.svd",
    "signature": "(x: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], *, full_matrices: bool = True, compute_uv: bool = True) -> Union[jax.Array, Tuple[jax.Array, jax.Array, jax.Array]]",
    "description": "Singular value decomposition."
  },
  "965": {
    "name": "triangular_solve",
    "module": "jax.lax.linalg",
    "fullName": "jax.lax.linalg.triangular_solve",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], b: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], *, left_side: bool = False, lower: bool = False, transpose_a: bool = False, conjugate_a: bool = False, unit_diagonal: bool = False) -> jax.Array",
    "description": "Triangular solve."
  },
  "966": {
    "name": "tridiagonal",
    "module": "jax.lax.linalg",
    "fullName": "jax.lax.linalg.tridiagonal",
    "signature": "(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], *, lower=True) -> Tuple[jax.Array, jax.Array, jax.Array, jax.Array]",
    "description": "Reduces a symmetric/Hermitian matrix to tridiagonal form."
  },
  "967": {
    "name": "tridiagonal_solve",
    "module": "jax.lax.linalg",
    "fullName": "jax.lax.linalg.tridiagonal_solve",
    "signature": "(dl: jax.Array, d: jax.Array, du: jax.Array, b: jax.Array) -> jax.Array",
    "description": "Computes the solution of a tridiagonal linear system."
  },
  "968": {
    "name": "DTypeLike",
    "module": "jax.lax.dtypes",
    "fullName": "jax.lax.dtypes.DTypeLike",
    "signature": "(*args, **kwargs)",
    "description": "No description available."
  },
  "969": {
    "name": "JAXType",
    "module": "jax.lax.dtypes",
    "fullName": "jax.lax.dtypes.JAXType",
    "signature": "(*args, **kwargs)",
    "description": "No description available."
  },
  "970": {
    "name": "canonicalize_dtype",
    "module": "jax.lax.dtypes",
    "fullName": "jax.lax.dtypes.canonicalize_dtype",
    "signature": "(dtype: Any, allow_opaque_dtype: bool = False) -> Union[numpy.dtype, Any]",
    "description": "Convert from a dtype to a canonical dtype based on config.x64_enabled."
  },
  "971": {
    "name": "cast",
    "module": "jax.lax.dtypes",
    "fullName": "jax.lax.dtypes.cast",
    "signature": "(typ, val)",
    "description": "Cast a value to a type."
  },
  "972": {
    "name": "check_user_dtype_supported",
    "module": "jax.lax.dtypes",
    "fullName": "jax.lax.dtypes.check_user_dtype_supported",
    "signature": "(dtype, fun_name=None)",
    "description": "No description available."
  },
  "973": {
    "name": "check_valid_dtype",
    "module": "jax.lax.dtypes",
    "fullName": "jax.lax.dtypes.check_valid_dtype",
    "signature": "(dtype: numpy.dtype) -> None",
    "description": "No description available."
  },
  "974": {
    "name": "coerce_to_array",
    "module": "jax.lax.dtypes",
    "fullName": "jax.lax.dtypes.coerce_to_array",
    "signature": "(x: Any, dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType, NoneType] = None) -> numpy.ndarray",
    "description": "Coerces a scalar or NumPy array to an np.array."
  },
  "975": {
    "name": "dtype",
    "module": "jax.lax.dtypes",
    "fullName": "jax.lax.dtypes.dtype",
    "signature": "(x: Any, *, canonicalize: bool = False) -> numpy.dtype",
    "description": "Return the dtype object for a value or type, optionally canonicalized based on X64 mode."
  },
  "976": {
    "name": "is_opaque_dtype",
    "module": "jax.lax.dtypes",
    "fullName": "jax.lax.dtypes.is_opaque_dtype",
    "signature": "(dtype: Any) -> bool",
    "description": "No description available."
  },
  "977": {
    "name": "is_python_scalar",
    "module": "jax.lax.dtypes",
    "fullName": "jax.lax.dtypes.is_python_scalar",
    "signature": "(x: Any) -> bool",
    "description": "No description available."
  },
  "978": {
    "name": "is_weakly_typed",
    "module": "jax.lax.dtypes",
    "fullName": "jax.lax.dtypes.is_weakly_typed",
    "signature": "(x: Any) -> bool",
    "description": "No description available."
  },
  "979": {
    "name": "issubdtype",
    "module": "jax.lax.dtypes",
    "fullName": "jax.lax.dtypes.issubdtype",
    "signature": "(a: Union[Any, str, numpy.dtype, jax._src.SupportsDType], b: Union[Any, str, numpy.dtype, jax._src.SupportsDType]) -> bool",
    "description": "Returns True if first argument is a typecode lower/equal in type hierarchy."
  },
  "980": {
    "name": "issubsctype",
    "module": "jax.lax.dtypes",
    "fullName": "jax.lax.dtypes.issubsctype",
    "signature": "(arg1, arg2)",
    "description": "Determine if the first argument is a subclass of the second argument."
  },
  "981": {
    "name": "overload",
    "module": "jax.lax.dtypes",
    "fullName": "jax.lax.dtypes.overload",
    "signature": "(func)",
    "description": "Decorator for overloaded functions/methods."
  },
  "982": {
    "name": "promote_types",
    "module": "jax.lax.dtypes",
    "fullName": "jax.lax.dtypes.promote_types",
    "signature": "(a: Union[Any, str, numpy.dtype, jax._src.SupportsDType], b: Union[Any, str, numpy.dtype, jax._src.SupportsDType]) -> numpy.dtype",
    "description": "Returns the type to which a binary operation should cast its arguments."
  },
  "983": {
    "name": "result_type",
    "module": "jax.lax.dtypes",
    "fullName": "jax.lax.dtypes.result_type",
    "signature": "(*args: Any, return_weak_type_flag: bool = False) -> Union[numpy.dtype, Tuple[numpy.dtype, bool]]",
    "description": "Convenience function to apply JAX argument dtype promotion."
  },
  "984": {
    "name": "scalar_type_of",
    "module": "jax.lax.dtypes",
    "fullName": "jax.lax.dtypes.scalar_type_of",
    "signature": "(x: Any) -> type",
    "description": "Return the scalar type associated with a JAX value."
  },
  "985": {
    "name": "to_complex_dtype",
    "module": "jax.lax.dtypes",
    "fullName": "jax.lax.dtypes.to_complex_dtype",
    "signature": "(dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType]) -> numpy.dtype",
    "description": "No description available."
  },
  "986": {
    "name": "to_inexact_dtype",
    "module": "jax.lax.dtypes",
    "fullName": "jax.lax.dtypes.to_inexact_dtype",
    "signature": "(dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType]) -> numpy.dtype",
    "description": "Promotes a dtype into an inexact dtype, if it is not already one."
  },
  "987": {
    "name": "to_numeric_dtype",
    "module": "jax.lax.dtypes",
    "fullName": "jax.lax.dtypes.to_numeric_dtype",
    "signature": "(dtype: Union[Any, str, numpy.dtype, jax._src.SupportsDType]) -> numpy.dtype",
    "description": "Promotes a dtype into an numeric dtype, if it is not already one."
  },
  "988": {
    "name": "api_boundary",
    "module": "jax.lax.dtypes.traceback_util",
    "fullName": "jax.lax.dtypes.traceback_util.api_boundary",
    "signature": "(fun: ~C) -> ~C",
    "description": "Wraps ``fun`` to form a boundary for filtering exception tracebacks."
  },
  "989": {
    "name": "cast",
    "module": "jax.lax.dtypes.traceback_util",
    "fullName": "jax.lax.dtypes.traceback_util.cast",
    "signature": "(typ, val)",
    "description": "Cast a value to a type."
  },
  "990": {
    "name": "filter_traceback",
    "module": "jax.lax.dtypes.traceback_util",
    "fullName": "jax.lax.dtypes.traceback_util.filter_traceback",
    "signature": "(tb: traceback) -> Optional[traceback]",
    "description": "No description available."
  },
  "991": {
    "name": "format_exception_only",
    "module": "jax.lax.dtypes.traceback_util",
    "fullName": "jax.lax.dtypes.traceback_util.format_exception_only",
    "signature": "(e: BaseException) -> str",
    "description": "No description available."
  },
  "992": {
    "name": "include_frame",
    "module": "jax.lax.dtypes.traceback_util",
    "fullName": "jax.lax.dtypes.traceback_util.include_frame",
    "signature": "(f: frame) -> bool",
    "description": "No description available."
  },
  "993": {
    "name": "register_exclusion",
    "module": "jax.lax.dtypes.traceback_util",
    "fullName": "jax.lax.dtypes.traceback_util.register_exclusion",
    "signature": "(path: str)",
    "description": "No description available."
  },
  "994": {
    "name": "as_hashable_function",
    "module": "jax.lax.dtypes.traceback_util.util",
    "fullName": "jax.lax.dtypes.traceback_util.util.as_hashable_function",
    "signature": "(closure)",
    "description": "No description available."
  },
  "995": {
    "name": "assert_unreachable",
    "module": "jax.lax.dtypes.traceback_util.util",
    "fullName": "jax.lax.dtypes.traceback_util.util.assert_unreachable",
    "signature": "(x)",
    "description": "No description available."
  },
  "996": {
    "name": "cache",
    "module": "jax.lax.dtypes.traceback_util.util",
    "fullName": "jax.lax.dtypes.traceback_util.util.cache",
    "signature": "(max_size=4096)",
    "description": "No description available."
  },
  "997": {
    "name": "canonicalize_axis",
    "module": "jax.lax.dtypes.traceback_util.util",
    "fullName": "jax.lax.dtypes.traceback_util.util.canonicalize_axis",
    "signature": "(axis, num_dims) -> int",
    "description": "Canonicalize an axis in [-num_dims, num_dims) to [0, num_dims)."
  },
  "998": {
    "name": "cast",
    "module": "jax.lax.dtypes.traceback_util.util",
    "fullName": "jax.lax.dtypes.traceback_util.util.cast",
    "signature": "(typ, val)",
    "description": "Cast a value to a type."
  },
  "999": {
    "name": "ceil_of_ratio",
    "module": "jax.lax.dtypes.traceback_util.util",
    "fullName": "jax.lax.dtypes.traceback_util.util.ceil_of_ratio",
    "signature": "(x, y)",
    "description": "No description available."
  },
  "1000": {
    "name": "check_toposort",
    "module": "jax.lax.dtypes.traceback_util.util",
    "fullName": "jax.lax.dtypes.traceback_util.util.check_toposort",
    "signature": "(nodes)",
    "description": "No description available."
  },
  "1001": {
    "name": "clear_all_weakref_lru_caches",
    "module": "jax.lax.dtypes.traceback_util.util",
    "fullName": "jax.lax.dtypes.traceback_util.util.clear_all_weakref_lru_caches",
    "signature": "()",
    "description": "No description available."
  },
  "1002": {
    "name": "concatenate",
    "module": "jax.lax.dtypes.traceback_util.util",
    "fullName": "jax.lax.dtypes.traceback_util.util.concatenate",
    "signature": "(xs: Iterable[Sequence[~T]]) -> List[~T]",
    "description": "Concatenates/flattens a list of lists."
  },
  "1003": {
    "name": "curry",
    "module": "jax.lax.dtypes.traceback_util.util",
    "fullName": "jax.lax.dtypes.traceback_util.util.curry",
    "signature": "(f)",
    "description": "Curries arguments of f, returning a function on any remaining arguments."
  },
  "1004": {
    "name": "distributed_debug_log",
    "module": "jax.lax.dtypes.traceback_util.util",
    "fullName": "jax.lax.dtypes.traceback_util.util.distributed_debug_log",
    "signature": "(*pairs)",
    "description": "Format and log `pairs` if config.jax_distributed_debug is enabled."
  },
  "1005": {
    "name": "flatten",
    "module": "jax.lax.dtypes.traceback_util.util",
    "fullName": "jax.lax.dtypes.traceback_util.util.flatten",
    "signature": "(xs: Iterable[Sequence[~T]]) -> List[~T]",
    "description": "Concatenates/flattens a list of lists."
  },
  "1006": {
    "name": "maybe_named_axis",
    "module": "jax.lax.dtypes.traceback_util.util",
    "fullName": "jax.lax.dtypes.traceback_util.util.maybe_named_axis",
    "signature": "(axis, if_pos, if_named)",
    "description": "No description available."
  },
  "1007": {
    "name": "memoize",
    "module": "jax.lax.dtypes.traceback_util.util",
    "fullName": "jax.lax.dtypes.traceback_util.util.memoize",
    "signature": "(f)",
    "description": "No description available."
  },
  "1008": {
    "name": "merge_lists",
    "module": "jax.lax.dtypes.traceback_util.util",
    "fullName": "jax.lax.dtypes.traceback_util.util.merge_lists",
    "signature": "(bs: Sequence[bool], l0: Sequence[~T], l1: Sequence[~T]) -> List[~T]",
    "description": "No description available."
  },
  "1009": {
    "name": "moveaxis",
    "module": "jax.lax.dtypes.traceback_util.util",
    "fullName": "jax.lax.dtypes.traceback_util.util.moveaxis",
    "signature": "(x, src, dst)",
    "description": "No description available."
  },
  "1010": {
    "name": "overload",
    "module": "jax.lax.dtypes.traceback_util.util",
    "fullName": "jax.lax.dtypes.traceback_util.util.overload",
    "signature": "(func)",
    "description": "Decorator for overloaded functions/methods."
  },
  "1011": {
    "name": "partition_list",
    "module": "jax.lax.dtypes.traceback_util.util",
    "fullName": "jax.lax.dtypes.traceback_util.util.partition_list",
    "signature": "(bs: Sequence[bool], l: Sequence[~T]) -> Tuple[List[~T], List[~T]]",
    "description": "No description available."
  },
  "1012": {
    "name": "set_module",
    "module": "jax.lax.dtypes.traceback_util.util",
    "fullName": "jax.lax.dtypes.traceback_util.util.set_module",
    "signature": "(module)",
    "description": "No description available."
  },
  "1013": {
    "name": "split_dict",
    "module": "jax.lax.dtypes.traceback_util.util",
    "fullName": "jax.lax.dtypes.traceback_util.util.split_dict",
    "signature": "(dct, names)",
    "description": "No description available."
  },
  "1014": {
    "name": "split_list",
    "module": "jax.lax.dtypes.traceback_util.util",
    "fullName": "jax.lax.dtypes.traceback_util.util.split_list",
    "signature": "(args: Sequence[~T], ns: Sequence[int]) -> List[List[~T]]",
    "description": "No description available."
  },
  "1015": {
    "name": "split_merge",
    "module": "jax.lax.dtypes.traceback_util.util",
    "fullName": "jax.lax.dtypes.traceback_util.util.split_merge",
    "signature": "(predicate, xs)",
    "description": "No description available."
  },
  "1016": {
    "name": "subvals",
    "module": "jax.lax.dtypes.traceback_util.util",
    "fullName": "jax.lax.dtypes.traceback_util.util.subvals",
    "signature": "(lst, replace)",
    "description": "No description available."
  },
  "1017": {
    "name": "toposort",
    "module": "jax.lax.dtypes.traceback_util.util",
    "fullName": "jax.lax.dtypes.traceback_util.util.toposort",
    "signature": "(end_nodes)",
    "description": "No description available."
  },
  "1018": {
    "name": "tuple_delete",
    "module": "jax.lax.dtypes.traceback_util.util",
    "fullName": "jax.lax.dtypes.traceback_util.util.tuple_delete",
    "signature": "(t, idx)",
    "description": "No description available."
  },
  "1019": {
    "name": "tuple_insert",
    "module": "jax.lax.dtypes.traceback_util.util",
    "fullName": "jax.lax.dtypes.traceback_util.util.tuple_insert",
    "signature": "(t, idx, val)",
    "description": "No description available."
  },
  "1020": {
    "name": "unflatten",
    "module": "jax.lax.dtypes.traceback_util.util",
    "fullName": "jax.lax.dtypes.traceback_util.util.unflatten",
    "signature": "(xs: Iterable[~T], ns: Sequence[int]) -> List[List[~T]]",
    "description": "Splits `xs` into subsequences of lengths `ns`."
  },
  "1021": {
    "name": "unzip2",
    "module": "jax.lax.dtypes.traceback_util.util",
    "fullName": "jax.lax.dtypes.traceback_util.util.unzip2",
    "signature": "(xys: Iterable[Tuple[~T1, ~T2]]) -> Tuple[Tuple[~T1, ...], Tuple[~T2, ...]]",
    "description": "Unzip sequence of length-2 tuples into two tuples."
  },
  "1022": {
    "name": "unzip3",
    "module": "jax.lax.dtypes.traceback_util.util",
    "fullName": "jax.lax.dtypes.traceback_util.util.unzip3",
    "signature": "(xyzs: Iterable[Tuple[~T1, ~T2, ~T3]]) -> Tuple[Tuple[~T1, ...], Tuple[~T2, ...], Tuple[~T3, ...]]",
    "description": "Unzip sequence of length-3 tuples into three tuples."
  },
  "1023": {
    "name": "use_cpp_class",
    "module": "jax.lax.dtypes.traceback_util.util",
    "fullName": "jax.lax.dtypes.traceback_util.util.use_cpp_class",
    "signature": "(cpp_cls)",
    "description": "A helper decorator to replace a python class with its C++ version"
  },
  "1024": {
    "name": "use_cpp_method",
    "module": "jax.lax.dtypes.traceback_util.util",
    "fullName": "jax.lax.dtypes.traceback_util.util.use_cpp_method",
    "signature": "(is_enabled=True)",
    "description": "A helper decorator to exclude methods from the set that are forwarded to C++ class"
  },
  "1025": {
    "name": "weakref_lru_cache",
    "module": "jax.lax.dtypes.traceback_util.util",
    "fullName": "jax.lax.dtypes.traceback_util.util.weakref_lru_cache",
    "signature": "(call: Callable, maxsize=2048)",
    "description": "Least recently used cache decorator with weakref support."
  },
  "1026": {
    "name": "wrap_name",
    "module": "jax.lax.dtypes.traceback_util.util",
    "fullName": "jax.lax.dtypes.traceback_util.util.wrap_name",
    "signature": "(name, transform_name)",
    "description": "No description available."
  },
  "1027": {
    "name": "wraps",
    "module": "jax.lax.dtypes.traceback_util.util",
    "fullName": "jax.lax.dtypes.traceback_util.util.wraps",
    "signature": "(wrapped: Callable, namestr: Optional[str] = None, docstr: Optional[str] = None, **kwargs) -> Callable[[~T], ~T]",
    "description": "Like functools.wraps, but with finer-grained control over the name and docstring"
  },
  "1028": {
    "name": "resize",
    "module": "jax.image",
    "fullName": "jax.image.resize",
    "signature": "(image, shape: Sequence[Union[int, Any]], method: Union[str, jax._src.image.scale.ResizeMethod], antialias: bool = True, precision=<Precision.HIGHEST: 2>)",
    "description": "Image resize."
  },
  "1029": {
    "name": "scale_and_translate",
    "module": "jax.image",
    "fullName": "jax.image.scale_and_translate",
    "signature": "(image, shape: Sequence[Union[int, Any]], spatial_dims: Sequence[int], scale, translation, method: Union[str, jax._src.image.scale.ResizeMethod], antialias: bool = True, precision=<Precision.HIGHEST: 2>)",
    "description": "Apply a scale and translation to an image."
  },
  "1030": {
    "name": "disable_x64",
    "module": "jax.experimental",
    "fullName": "jax.experimental.disable_x64",
    "signature": "()",
    "description": "Experimental context manager to temporarily disable X64 mode."
  },
  "1031": {
    "name": "enable_x64",
    "module": "jax.experimental",
    "fullName": "jax.experimental.enable_x64",
    "signature": "(new_val: bool = True)",
    "description": "Experimental context manager to temporarily enable X64 mode."
  },
  "1032": {
    "name": "io_callback",
    "module": "jax.experimental",
    "fullName": "jax.experimental.io_callback",
    "signature": "(callback: 'Callable[..., Any]', result_shape_dtypes: 'Any', *args: 'Any', ordered: 'bool' = False, **kwargs: 'Any')",
    "description": "Calls an impure Python callback."
  },
  "1033": {
    "name": "contextmanager",
    "module": "jax.experimental.x64_context",
    "fullName": "jax.experimental.x64_context.contextmanager",
    "signature": "(func)",
    "description": "@contextmanager decorator."
  },
  "1034": {
    "name": "disable_x64",
    "module": "jax.experimental.x64_context",
    "fullName": "jax.experimental.x64_context.disable_x64",
    "signature": "()",
    "description": "Experimental context manager to temporarily disable X64 mode."
  },
  "1035": {
    "name": "enable_x64",
    "module": "jax.experimental.x64_context",
    "fullName": "jax.experimental.x64_context.enable_x64",
    "signature": "(new_val: bool = True)",
    "description": "Experimental context manager to temporarily enable X64 mode."
  },
  "1036": {
    "name": "initialize_cache",
    "module": "jax.experimental.compilation_cache.compilation_cache",
    "fullName": "jax.experimental.compilation_cache.compilation_cache.initialize_cache",
    "signature": "(path)",
    "description": "Creates a global cache object."
  },
  "1037": {
    "name": "is_initialized",
    "module": "jax.experimental.compilation_cache.compilation_cache",
    "fullName": "jax.experimental.compilation_cache.compilation_cache.is_initialized",
    "signature": "()",
    "description": "No description available."
  },
  "1038": {
    "name": "reset_cache",
    "module": "jax.experimental.compilation_cache.compilation_cache",
    "fullName": "jax.experimental.compilation_cache.compilation_cache.reset_cache",
    "signature": "()",
    "description": "No description available."
  },
  "1039": {
    "name": "canonicalize_dtype",
    "module": "jax.dtypes",
    "fullName": "jax.dtypes.canonicalize_dtype",
    "signature": "(dtype: Any, allow_opaque_dtype: bool = False) -> Union[numpy.dtype, Any]",
    "description": "Convert from a dtype to a canonical dtype based on config.x64_enabled."
  },
  "1040": {
    "name": "issubdtype",
    "module": "jax.dtypes",
    "fullName": "jax.dtypes.issubdtype",
    "signature": "(a: Union[Any, str, numpy.dtype, jax._src.SupportsDType], b: Union[Any, str, numpy.dtype, jax._src.SupportsDType]) -> bool",
    "description": "Returns True if first argument is a typecode lower/equal in type hierarchy."
  },
  "1041": {
    "name": "result_type",
    "module": "jax.dtypes",
    "fullName": "jax.dtypes.result_type",
    "signature": "(*args: Any, return_weak_type_flag: bool = False) -> Union[numpy.dtype, Tuple[numpy.dtype, bool]]",
    "description": "Convenience function to apply JAX argument dtype promotion."
  },
  "1042": {
    "name": "scalar_type_of",
    "module": "jax.dtypes",
    "fullName": "jax.dtypes.scalar_type_of",
    "signature": "(x: Any) -> type",
    "description": "Return the scalar type associated with a JAX value."
  },
  "1043": {
    "name": "initialize",
    "module": "jax.distributed",
    "fullName": "jax.distributed.initialize",
    "signature": "(coordinator_address: Optional[str] = None, num_processes: Optional[int] = None, process_id: Optional[int] = None, local_device_ids: Union[int, Sequence[int], NoneType] = None)",
    "description": "Initializes the JAX distributed system."
  },
  "1044": {
    "name": "shutdown",
    "module": "jax.distributed",
    "fullName": "jax.distributed.shutdown",
    "signature": "()",
    "description": "Shuts down the distributed system."
  },
  "1045": {
    "name": "breakpoint",
    "module": "jax.debug",
    "fullName": "jax.debug.breakpoint",
    "signature": "(*, backend: 'Optional[str]' = None, filter_frames: 'bool' = True, num_frames: 'Optional[int]' = None, ordered: 'bool' = False, **kwargs)",
    "description": "Enters a breakpoint at a point in a program."
  },
  "1046": {
    "name": "callback",
    "module": "jax.debug",
    "fullName": "jax.debug.callback",
    "signature": "(callback: Callable[..., Any], *args: Any, ordered: bool = False, **kwargs: Any) -> None",
    "description": "Calls a stageable Python callback."
  },
  "1047": {
    "name": "inspect_array_sharding",
    "module": "jax.debug",
    "fullName": "jax.debug.inspect_array_sharding",
    "signature": "(value, *, callback: Callable[[jaxlib.xla_extension.Sharding], NoneType])",
    "description": "Enables inspecting array sharding inside JIT-ted functions."
  },
  "1048": {
    "name": "print",
    "module": "jax.debug",
    "fullName": "jax.debug.print",
    "signature": "(fmt: str, *args, ordered: bool = False, **kwargs) -> None",
    "description": "Prints values and works in staged out JAX functions."
  },
  "1049": {
    "name": "visualize_array_sharding",
    "module": "jax.debug",
    "fullName": "jax.debug.visualize_array_sharding",
    "signature": "(arr, **kwargs)",
    "description": "Visualizes an array's sharding."
  },
  "1050": {
    "name": "visualize_sharding",
    "module": "jax.debug",
    "fullName": "jax.debug.visualize_sharding",
    "signature": "(shape: Sequence[int], sharding: jaxlib.xla_extension.Sharding, *, use_color: bool = True, scale: float = 1.0, min_width: int = 9, max_width: int = 80, color_map: Optional[Callable[[float], Tuple[float, float, float, float]]] = None)",
    "description": "Visualizes a ``Sharding`` using ``rich``."
  }
}